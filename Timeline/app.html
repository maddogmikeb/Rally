<meta name="Name" content="App: Portfolio Timeline Extended v2" />
<meta name="Version" content="2017.02.14" />
<meta name="Vendor" content="MaddogMikeB" />
<script type="text/javascript" src="/apps/2.0/sdk.js"></script>
<script type="text/javascript">
    (function () {

        var Ext = window.Ext4 || window.Ext;

        Rally.ui.chart.Chart.prototype._renderChart = function () {
            this._unmask();

            var chartConfig = this.getChartConfig(),
                chartEl = this.down('#chart');

            if (chartEl) {
                chartConfig.xAxis = chartConfig.xAxis || {};
                chartConfig.xAxis.categories = this.chartData.categories;

                this._setChartColorsOnSeries(this.chartData.series);

                var me = this;
                var highChartConfig = {
                    xtype: 'highchart',
                    chartConfig: chartConfig,
                    series: this.chartData.series,
                    initAnimAfterLoad: false,
                    afterChartRendered: function (chart) {
                        try {
                            if (chart.chartHeight > me.getHeight()) {
                                me.setHeight(chart.chartHeight * 1.1);
                            }
                        } catch (e) {}
                        // hack to get the chart early 
                        me.down('highchart').chart = chart;
                        me._setChartReady();
                        me.fireEvent('chartRendered', me);
                    }
                };

                chartEl.add(highChartConfig);
            }
        };

        function extendHighchartsScatter(H) {
            var scatterType = H.seriesTypes.scatter;
            H.seriesTypes.scatter = H.extendClass(H.seriesTypes.scatter, {
                translate: function () {
                    var series = this;
                    scatterType.prototype.translate.call(this, arguments);
                    H.each(series.points, function (point) {
                        // Make milestones sit at the top of the chart 
                        point.plotY = 0;
                    }, this);
                },
                getColumnMetrics: function () {
                    return scatterType.prototype.getColumnMetrics.call(this);
                }
            });
        }

        /** 
         *   Taken from http://jsfiddle.net/gh/get/jquery/3.1.1/highcharts/highcharts/tree/samples/highcharts/studies/xrange-series/ 
         */
        function extendHighchartsWithXRangePlugin(H) {
            var defaultPlotOptions = H.getOptions().plotOptions,
                columnType = H.seriesTypes.column,
                each = H.each,
                extendClass = H.extendClass,
                pick = H.pick,
                Point = H.Point,
                Series = H.Series;

            defaultPlotOptions.xrange = H.merge(defaultPlotOptions.column, {
                tooltip: {
                    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>'
                }
            });

            H.seriesTypes.column = H.extendClass(columnType, {
                pointClass: extendClass(Point, {
                    getLabelConfig: function () {
                        var cfg = Point.prototype.getLabelConfig.call(this);
                        cfg.x2 = this.x2;
                        cfg.yCategory = this.yCategory = this.series.yAxis.categories &&
                            this.series.yAxis.categories[this.y];
                        return cfg;
                    }
                }),
                type: 'xrange',
                forceDL: true,
                parallelArrays: ['x', 'x2', 'y'],
                requireSorting: false,
                animate: H.seriesTypes.line.prototype.animate,

                getColumnMetrics: function () {
                    var metrics, chart = this.chart;

                    function swapAxes() {
                        each(chart.series, function (s) {
                            var xAxis = s.xAxis;
                            s.xAxis = s.yAxis;
                            s.yAxis = xAxis;
                        });
                    }
                    swapAxes();
                    this.yAxis.closestPointRange = 1;
                    metrics = columnType.prototype.getColumnMetrics.call(this);
                    swapAxes();
                    return metrics;
                },

                cropData: function (xData, yData, min, max) {
                    var crop = Series.prototype.cropData.call(this, this.x2Data, yData, min, max);
                    crop.xData = xData.slice(crop.start, crop.end);
                    return crop;
                },

                translate: function () {
                    columnType.prototype.translate.apply(this, arguments);
                    var series = this,
                        xAxis = series.xAxis,
                        metrics = series.columnMetrics,
                        minPointLength = series.options.minPointLength || 0;

                    H.each(series.points, function (point) {
                        var plotX = point.plotX,
                            plotX2 = xAxis.toPixels(H.pick(point.x2, point.x + (point.len || 0)),
                                true),
                            width = plotX2 - plotX,
                            widthDifference;

                        if (minPointLength) {
                            widthDifference = width < minPointLength ? minPointLength - width :
                                minPointLength;
                            plotX -= widthDifference / 2;
                            plotX2 += widthDifference / 2;
                        }

                        plotX = Math.max(plotX, -minPointLength);
                        plotX2 = Math.min(Math.max(plotX2, -minPointLength), xAxis.len +
                            minPointLength);

                        var height = point.height || metrics.width;
                        // var offset = point.plotY + ((point.series.chart.chartHeight / point.series
                        //    .chart.series.length) / -2) + ((metrics.width - (point.height ||
                        //    metrics.width)) / 2);

                        var y = point.plotY - (height / 2);
                        if (isNaN(y)) {
                            debugger;
                        }
                        if (isNaN(plotX)) {
                            debugger;
                        }

                        point.shapeArgs = {
                            x: plotX,
                            y: y, //offset,
                            width: plotX2 - plotX,
                            height: height
                        };
                        if (!point.tooltipPos) {
                            point.tooltipPos = [];
                        }
                        point.tooltipPos[0] += width / 2;
                        point.tooltipPos[1] -= metrics.width / 2;
                    }, this);
                }
            });

            H.wrap(H.Axis.prototype, 'getSeriesExtremes', function (proceed) {
                var axis = this,
                    dataMax, modMax;
                proceed.call(this);
                if (this.isXAxis) {
                    dataMax = pick(axis.dataMax, Number.MIN_VALUE);
                    each(this.series, function (series) {
                        each(series.x2Data || [], function (val) {
                            if (val > dataMax) {
                                dataMax = val;
                                modMax = true;
                            }
                        });
                    });
                    if (modMax) {
                        axis.dataMax = dataMax;
                    }
                }
            });
        }

        function extendHighchartsTooltip(H) {
            var render = H.Tick.prototype.render;
            H.Tick.prototype.render = function () {
                render.apply(this, arguments);
                if (this.axis.options.labels.enabled &&
                    this.axis.options.labels.events &&
                    this.axis.options.labels.events.click) {
                    var series = Ext.Array.filter(this.axis.series, function (seri) {
                        return this.label && (seri.name === this.label.text);
                    }, this);
                    if (series && series.length > 0) series = series[0];
                    if (this.label) {
                        this.label.on('click', (function () {
                            this.options.labels.events.click.apply(this, arguments);

                        }).bind(this.axis, this.label, series));
                    }
                }
            };

            var onContainerPointerMove = H.Pointer.prototype.onContainerPointerMove;
            H.Pointer.prototype.onContainerPointerMove = function() {
                try {// keeps throwing errors coz translateMSPointer doesnt always work
                    onContainerPointerMove.apply(this, arguments);
                } catch (e){}
            };

            var onDocumentPointerUp = H.Pointer.prototype.onDocumentPointerUp;
            H.Pointer.prototype.onDocumentPointerUp = function() {
                try {// keeps throwing errors coz translateMSPointer doesnt always work
                    onDocumentPointerUp.apply(this, arguments);
                } catch (e){}
            };
        }

        function extendHighchartsExport(HC) {
            HC.getSVG = function (charts, options) {
                var svgArr = [],
                    top = 0,
                    width = 0;
                HC.each(charts, function (chart) {
                    var svg = chart.container.children[0].outerHTML || chart.getSVG(options);
                    svg = svg.replace('<svg', '<g transform="translate(0,' + top + ')" ');
                    svg = svg.replace('</svg>', '</g>');
                    top += chart.chartHeight;
                    width = Math.max(width, chart.chartWidth);
                    svgArr.push(svg);
                });
                return '<svg height="' + top + '" width="' + width +
                    '" version="1.1" xmlns="http://www.w3.org/2000/svg">' +
                    svgArr.join('') + '</svg>';
            };

            HC.exportCharts = function (charts, options) {
                options = HC.merge(HC.getOptions().exporting, options);
                options.url = options.url.replace(/^http:\/\//i, location.protocol + '//');
                HC.post(options.url, {
                    filename: options.filename || 'chart',
                    type: options.type,
                    width: options.width,
                    svg: HC.getSVG(charts)
                });
            };

            HC.post = function (url, data, formAttributes) {
                var name;
                var f = window.document.createElement('form');
                f.setAttribute('method', 'post');
                f.setAttribute('action', url);
                f.setAttribute('enctype', 'multipart/form-data');
                f.setAttribute('style', 'display: none;');

                for (att in formAttributes) {
                    f.setAttribute(attr, formAttributes[attr]);
                }

                for (name in data) {
                    var input = window.document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    input.setAttribute('name', name);
                    input.setAttribute('value', data[name]);
                    f.appendChild(input);
                }

                window.document.getElementsByTagName('body')[0].appendChild(f);

                f.submit();
                f.remove();
            };

        }

        Element.prototype.remove = function () {
            this.parentElement.removeChild(this);
        }

        NodeList.prototype.remove = HTMLCollection.prototype.remove = function () {
            for (var i = this.length - 1; i >= 0; i--) {
                if (this[i] && this[i].parentElement) {
                    this[i].parentElement.removeChild(this[i]);
                }
            }
        }

        Rally.ExtendHighcharts = function (HC) {
            extendHighchartsWithXRangePlugin(HC);
            extendHighchartsScatter(HC);
            extendHighchartsTooltip(HC);
            extendHighchartsExport(HC);
        }

    })();
</script>
<script type="text/javascript">
    (function () {

        var Ext = window.Ext4 || window.Ext;

        Ext.define('DataLoader', {

            requires: ['Rally.data.Ranker'],

            _buildQueryFilter: function (model, settingName) {
                var queries = [];
                try {
                    var setting = this.getSetting(settingName);
                    if (!setting && this.getSettings().query) {
                        var fieldIndex = Ext.Array.map(Ext.Array.filter(this.getSettingsFields(),
                            function (v) {
                                return v.type === 'query';
                            }), function (v) {
                            return v.name;
                        }).indexOf(settingName);
                        setting = this.getSettings().query.split(",")[fieldIndex];
                        this.settings[settingName] = setting;
                    }
                    if (setting) {
                        setting = new Ext.Template(setting).apply({
                            projectName: this.getContext().getProject().Name,
                            projectOid: this.getContext().getProject().ObjectID,
                            user: this.getContext().getUser()._ref
                        });
                        queries.push(Rally.data.QueryFilter.fromQueryString(setting));
                        console.log([settingName, setting].concat(queries));
                    }
                } catch (e) {
                    Rally.ui.notify.Notifier.showError({
                        message: settingName + ': ' + e.message
                    });
                }
                return queries;
            },

            _buildPortfolioItemQueryFilter: function (scope) {
                return this._buildQueryFilter.apply(scope, [].concat(arguments, 'PortfolioItemFilter'));
            },

            _buildMilestoneQueryFilter: function (scope) {
                return this._buildQueryFilter.apply(scope, [].concat(arguments, 'MilestoneFilter'));
            },

            _buildReleasesQueryFilter: function (scope) {
                return this._buildQueryFilter.apply(scope, [].concat(arguments, 'ReleasesFilter'));
            },

            _buildIterationsQueryFilter: function (scope) {
                return this._buildQueryFilter.apply(scope, [].concat(arguments, 'IterationsFilter'));
            },

            _buildPortfolioItemDependencyQueryFilter: function (scope, objectID, type) {
                var q = '(' + type + '.ObjectID contains "' + objectID + '")';
                return [Rally.data.QueryFilter.fromQueryString(q)];
            },

            LoadData: function (events, config) {

                if (!config) config = {};
                if (!config.portfolioItem) config.portfolioItem = {};

                Deft.Promise.all(
                    [
                        this._getPortfolioItems(events.scope, config.portfolioItem.type, config.portfolioItem
                            .limit),
                        this._getMilestoneItems(events.scope),
                        this._getReleases(events.scope),
                        this._getIterations(events.scope),
                    ]
                ).then({
                    success: function () {
                        if (events) {
                            events.success.apply(events.scope || this, arguments);
                        }
                    },
                    failure: function () {
                        events.failure.apply(events.scope || this, arguments);
                    },
                    scope: events.scope
                });
            },

            _getIterations: function (scope) {
                var deferred = Ext.create('Deft.Deferred');

                Ext.create('Rally.data.wsapi.Store', {
                    model: 'Iteration',
                    fetch: ['ObjectID', 'Project', 'Name',
                        'Theme', 'StartDate', 'EndDate'
                    ],
                    context: scope.getContext().getDataContext(),
                    limit: Infinity,
                    filters: this._buildIterationsQueryFilter(scope)
                }).load({
                    callback: function (records, operation) {
                        if (operation.wasSuccessful()) {
                            deferred.resolve(records.length > 0 ? records : []);
                        } else {
                            deferred.reject(this.model.displayName + " - " + operation.error &&
                                operation.error.errors ?
                                operation.error.errors.join(',') : 'Uknown error');
                        }
                    }
                });

                return deferred.promise;
            },

            _getReleases: function (scope) {
                var deferred = Ext.create('Deft.Deferred');

                Ext.create('Rally.data.wsapi.Store', {
                    model: 'Release',
                    autoLoad: true,
                    fetch: ['ObjectID', 'Project', 'Name', 'Theme',
                        'ReleaseStartDate', 'ReleaseDate'
                    ],
                    context: scope.getContext().getDataContext(),
                    limit: Infinity,
                    filters: this._buildReleasesQueryFilter(scope)
                }).load({
                    callback: function (records, operation) {
                        if (operation.wasSuccessful()) {
                            deferred.resolve(records.length > 0 ? records : []);
                        } else {
                            deferred.reject(this.model.displayName + " - " + operation.error &&
                                operation.error.errors ?
                                operation.error.errors.join(',') : 'Uknown error');
                        }
                    }
                });

                return deferred.promise;
            },

            _getMilestoneItems: function (scope) {
                var deferred = Ext.create('Deft.Deferred');

                Ext.create('Rally.data.wsapi.Store', {
                    model: 'Milestone',
                    autoLoad: true,
                    fetch: ['ObjectID', 'FormattedID', 'DisplayColor', 'Name',
                        'Notes', 'TargetDate', 'TargetProject'
                    ],
                    context: scope.getContext().getDataContext(),
                    limit: Infinity,
                    filters: this._buildMilestoneQueryFilter(scope)
                }).load({
                    callback: function (records, operation) {
                        if (operation.wasSuccessful()) {
                            deferred.resolve(records.length > 0 ? records : []);
                        } else {
                            deferred.reject(this.model.displayName + " - " + operation.error &&
                                operation.error.errors ?
                                operation.error.errors.join(',') : 'Uknown error');
                        }
                    }
                });

                return deferred.promise;
            },

            _getRankField: function () {
                return Rally.getApp().getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled ?
                    Rally.data.Ranker.RANK_FIELDS.DND :
                    Rally.data.Ranker.RANK_FIELDS.MANUAL;
            },

            _getPortfolioItems: function (scope, portfolioItemType, portfoliItemLimit) {
                var deferred = Ext.create('Deft.Deferred');
                Ext.create('Rally.data.wsapi.Store', {
                    model: portfolioItemType,
                    autoLoad: true,
                    fetch: ['ObjectID', 'FormattedID', 'DisplayColor', 'Name',
                        'Description', 'PlannedStartDate', 'PlannedEndDate',
                        'ActualStartDate', 'ActualEndDate', 'CreationDate',
                        this._getRankField(), 'State', 'Predecessors', 'Successors',
                        'Release', 'ReleaseDate', 'ReleaseStartDate', 'Name',
                        'LateChildCount', 'Notes', 'UnEstimatedLeafStoryCount',
                        'PercentDoneByStoryPlanEstimate', 'PercentDoneByStoryCount',
                        'LeafStoryPlanEstimateTotal', 'LeafStoryCount',
                        'DirectChildrenCount', 'AcceptedLeafStoryPlanEstimateTotal',
                        'AcceptedLeafStoryCount'
                    ],
                    context: scope.getContext().getDataContext(),
                    limit: portfoliItemLimit || Infinity,
                    filters: this._buildPortfolioItemQueryFilter(scope),
                    sorters: [{
                        property: this._getRankField(),
                        direction: 'DESC'
                    }],
                }).load({
                    callback: function (records, operation) {
                        if (operation.wasSuccessful()) {
                            if (portfoliItemLimit && records.length > portfoliItemLimit) {
                                records.reverse();
                                records = records.slice(0, portfoliItemLimit);
                                records.reverse();
                            }
                            deferred.resolve(records.length > 0 ? records : []);
                        } else {
                            deferred.reject(this.model.displayName + " - " + operation.error &&
                                operation.error.errors ?
                                operation.error.errors.join(',') : 'Uknown error');
                        }
                    }
                });

                return deferred.promise;
            },

            GetDependencies: function (events) {
                var items = events.config && events.config.items ? events.config.items : [];
                var queries = [];
                Ext.Array.forEach(items, function (i) {
                    if (i.raw.Successors.Count > 0) {
                        queries.push(this._getPortfolioItemDependencies(events.scope, i.raw.ObjectID,
                            'Predecessors'));
                    }
                    if (i.raw.Predecessors.Count > 0) {
                        queries.push(this._getPortfolioItemDependencies(events.scope, i.raw.ObjectID,
                            'Successors'));
                    }
                }, this);
                Deft.Promise.all(queries).then({
                    success: function () {
                        if (events) {
                            events.success.apply(events.scope || this, arguments);
                        }
                    },
                    failure: function () {
                        events.failure.apply(events.scope || this, arguments);
                    },
                    scope: events.scope
                });
            },

            _getPortfolioItemDependencies: function (scope, item, type) {
                var deferred = Ext.create('Deft.Deferred');

                Ext.create('Rally.data.wsapi.Store', {
                    model: Rally.getApp().getSetting('Portfolio Item Type'),
                    autoLoad: true,
                    fetch: ['ObjectID', 'FormattedID', 'DisplayColor', 'Name',
                        'Description', 'PlannedStartDate', 'PlannedEndDate',
                        'ActualStartDate', 'ActualEndDate', 'CreationDate',
                        this._getRankField(), 'State', 'Predecessors', 'Successors'
                    ],
                    context: scope.getContext().getDataContext(),
                    limit: Infinity,
                    filters: this._buildPortfolioItemDependencyQueryFilter(scope, item, type),
                }).load({
                    callback: function (records, operation) {
                        if (operation.wasSuccessful()) {
                            deferred.resolve({
                                item: item,
                                type: type,
                                records: records.length > 0 ? records : []
                            });
                        } else {
                            deferred.reject(this.model.displayName + " - " + operation.error &&
                                operation.error.errors ?
                                operation.error.errors.join(',') : 'Uknown error');
                        }
                    }
                });

                return deferred.promise;
            },
        });

        Ext.define('MaskedApp', {
            extend: 'Rally.app.App',

            _showMask: function (msg) {
                var app = Rally.getApp();
                if (app.getEl()) {
                    app.getEl().unmask();
                    app.getEl().mask(msg);
                }
            },

            _hideMask: function () {
                var app = Rally.getApp();
                app.getEl().unmask();
            },
        });

        Ext.define('PortfolioTimelineExtendedApp', {
            extend: 'MaskedApp',
            settingsScope: 'project',
            requires: ['DataLoader'],

            chart: null,
            dataLoader: null,
            data: null,

            dependencyMarker: '' +
                '      <marker id="dependencyMarker" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto-start-reverse" markerUnits="userSpaceOnUse" style="overflow:visible"> ' +
                '          <path d="M0,0 L0,6 L9,3 z" fill="#660066" /> ' +
                '      </marker> ',

            unknownMarker: '' +
                '    <marker id="unknownMarker" markerWidth="8" markerHeight="8" refX="4" refY="4" markerUnits="userSpaceOnUse"> ' +
                '         <circle cx="4" cy="4" r="8" fill="#660066" /> ' +
                '    </marker> ',


            getOptions: function () {
                return [{
                    text: 'Export Chart',
                    handler: this.exportChart,
                    scope: this
                }];
            },

            config: {
                defaultSettings: {
                    'Portfolio Item Type': 'PortfolioItem/Feature',
                    'query': [
                        "", // PortfolioItem
                        "(TargetProject.ObjectID = {projectOid})", // Milestone
                        "(Project.ObjectID = {projectOid})", // Release
                        "(Project.ObjectID = {projectOid})" // Iteration
                    ].join(','),
                    'PortfolioItemFilter': 0,
                }
            },

            getSettingsFields: function () {
                return [{
                    xtype: 'rallycombobox',
                    name: 'Portfolio Item Type',
                    storeConfig: {
                        fields: ['value', 'range'],
                        data: [{
                            'value': 'PortfolioItem/Feature',
                            'range': 'Feature'
                        }, {
                            'value': 'PortfolioItem/Portfolio',
                            'range': 'Portfolio'
                        }]
                    },
                    storeType: 'Ext.data.Store',
                    fieldLabel: 'Portfolio Item Type',
                    displayField: 'range',
                    valueField: 'value'
                }, {
                    name: 'PortfolioItemFilter',
                    config: {
                        fieldLabel: 'Portfolio Item Filter',
                    },
                    type: 'query'
                }, {
                    name: 'PortfolioItemLimit',
                    xtype: 'rallynumberfield',
                    value: this.getSetting('PortfolioItemLimit'),
                    config: {
                        fieldLabel: 'Portfolio Item Limit',
                    },
                }, {
                    name: 'MilestoneFilter',
                    config: {
                        fieldLabel: 'Milestone Filter',
                    },
                    type: 'query'
                }, {
                    name: 'ReleasesFilter',
                    config: {
                        fieldLabel: 'Release Filter',
                    },
                    type: 'query'
                }, {
                    name: 'IterationsFilter',
                    config: {
                        fieldLabel: 'Iteration Filter',
                    },
                    type: 'query'
                }];
            },

            launch: function () {
                this.dataLoader = Ext.create('DataLoader');
                this._showMask("Loading...");
                this._addButton.apply(this);
                this._addChecks.apply(this);
                this._loadData.apply(this);
            },

            _hideMask: function () {
                this.callParent(arguments);
                this.chart.getEl().unmask();
            },

            exportChart: function () {
                if (!this.chart) return;

                var chart = this.chart.down('highchart').chart;
                if (!chart) return;

                window.Highcharts.exportCharts([chart], {
                    filename: encodeURIComponent(this.getContext().getProject().Name),
                    type: 'image/png',
                });

                this._loadData.apply(this);
            },

            _updateChart: function (success, portfolioItems, milestones, timeboxes) {
                if (!success) {
                    Rally.ui.notify.Notifier.showError({
                        message: 'Error'
                    });
                    return;
                }

                var plotBands = Ext.Array.unique(this._createPlotbandsFromTimeboxes(timeboxes));
                var categories = Ext.Array.unique(Ext.Array.map(portfolioItems, this._categoryFormatter));
                var seriesItems = this._createSeriesFromPortfolioItems(categories, portfolioItems);
                var ms = Ext.Array.unique(this._createSeriesFromMilestones(milestones));

                this.data = portfolioItems; // get a record of the portfolio items 

                var series = [].concat(seriesItems, ms);
                var chartConfig = this._chartConfig(plotBands, categories, series);

                if (this.chart) this.chart.destroy();

                this.chart = Ext.create('Rally.ui.chart.Chart', {
                    chartConfig: chartConfig,
                    chartData: {
                        series: series
                    },
                    listeners: {
                        afterrender: this._hideMask,
                        chartRendered: function () {
                            var releases = this.down("checkbox[fieldLabel='Releases']");
                            this.onTimeboxCheckboxChange.apply(this, [releases, releases.value]);

                            var iterations = this.down("checkbox[fieldLabel='Iterations']");
                            this.onTimeboxCheckboxChange.apply(this, [iterations,
                                iterations.value
                            ]);

                            var app = Rally.getApp();
                            var chartHC = app.chart.down('highchart').chart;

                            var dependencyMarker = document.createElementNS(
                                'http://www.w3.org/2000/svg', 'marker');
                            dependencyMarker.innerHTML += app.dependencyMarker;
                            chartHC.renderer.defs.element.appendChild(dependencyMarker);

                            var unknownMarker = document.createElementNS(
                                'http://www.w3.org/2000/svg', 'marker');
                            unknownMarker.innerHTML += app.unknownMarker;
                            chartHC.renderer.defs.element.appendChild(unknownMarker);

                            app._getDependencies.apply(app, [portfolioItems]);
                            app._fixYAxisLabels.apply(app, arguments);
                        },
                        scope: this,
                    }
                });

                this.add(this.chart);
            },

            pop: null,

            showTooltip: function (event, type) {
                function ensureLbl(chart) {
                    if (!chart.lbl) {
                        chart.lbl = chart.renderer.label('')
                            .attr({
                                padding: 10,
                                r: 10,
                                fill: 'white',
                            }).css({
                                color: '#666'
                            }).add();
                    }
                    return chart;
                }
                if (type === 'Milestone') {
                    var chart = this.chart.down('highchart').chart;
                    if (!chart) return;
                    var date = event.currentTarget.series.options.data[0].x;
                    if (!date) return;
                    var text = '<br><b>Milestone: ' + 
                        event.currentTarget.series.options.name +
                        ' (' + new Date(date).toLocaleDateString('en-AU') + ')</b>';
                    ensureLbl(chart).lbl.show().attr({text: text});
                } else if (type === 'Timebox') {
                    var chart = this.axis.chart;  
                    var text = '<br><b>' + (this.options.isIteration ? 'Iteration' : 'Release') +
                        ': ' + this.label.text +
                        ' (' + new Date(this.options.from).toLocaleDateString('en-AU') +
                        '-' + new Date(this.options.to).toLocaleDateString('en-AU') + ')</b>';
                    ensureLbl(chart).lbl.show().attr({text: text});
                } else if (type === 'Items') {
                    var records = Ext.Array.filter(this.data, function (record) {
                        return record.raw.ObjectID === event.currentTarget.ObjectID;
                    });
                    if (records.length === 0) return;
                    var record = records[0];
                    this.pop = Rally.ui.popover.PopoverFactory.bake({
                        field: 'PercentDoneByStoryPlanEstimate',
                        //type: this.getSetting('Portfolio Item Type'),
                        oid: record.raw.ObjectID,
                        record: record,
                        target: Ext.Element.get(event.currentTarget.graphic.element) || Ext.Element
                            .getActiveElement(),
                        percentDoneData: record.data,
                        percentDoneName: "PercentDoneByStoryCount",
                        piRef: record.data._ref,
                        viewportPadding: [15, 25, 15, 215]
                    });
                }
            },

            hideTooltip: function () {
                if (this.pop) {
                    this.pop.hide();
                    this.pop.destroy();
                }
                this.pop = null;
                if (this.axis && this.axis.chart && this.axis.chart.lbl) {
                    //this.axis.chart.lbl.destroy();
                    //this.axis.chart.lbl = null;
                    this.axis.chart.lbl.hide();
                }
            },

            _fixYAxisLabels: function () {
                // Not sure why but sometimes the x and y of the label was not set correctly.
                var chart = this.chart.down('highchart').chart;

                var that = this;
                var oldZoom = chart.zoom;
                chart.zoom = function () {
                    that.onDependencyCheckboxChange.apply(that, [null, false]);
                    oldZoom.apply(this, arguments);
                };

                var oldZoomOut = chart.zoomOut;
                chart.zoomOut = function () {
                    oldZoomOut.apply(this, arguments);
                    var dependencies = that.down("checkbox[fieldLabel='Dependencies']");
                    that.onDependencyCheckboxChange.apply(that, [dependencies, dependencies.value]);
                };

                function hexToRgbA(hex, alpha){
                    var c;
                    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                        c= hex.substring(1).split('');
                        if(c.length== 3){
                            c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                        }
                        c= '0x'+c.join('');
                        return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+',' + alpha + ')';
                    }
                    throw new Error('Bad Hex');
                }

                var ticks = chart.axes[1].ticks;
                if (!ticks) return;
                for (var t in ticks) {
                    var tick = ticks[t];
                    var label = tick.label;
                    if (!label) continue;
                    var s = ticks[t].axis.series[ticks[t].pos];
                    label.element.setAttribute("labelfor", s.options.ObjectID);
                    label.element.setAttribute("z", 20);  
                    if (label.x != label.xy.x) {
                        label.element.setAttribute("x", label.xy.x);
                        for (var i = 0; i < label.element.childElementCount; i++) {
                            label.element.childNodes[i].setAttribute("x", label.xy.x);
                        }
                        label.x = label.xy.x;
                    }
                    if (label.y != label.xy.y) {
                        label.element.setAttribute("y", label.xy.y);
                        for (var i = 0; i < label.element.childElementCount; i++) {
                            label.element.childNodes[i].setAttribute("y", label.xy.y);
                        }
                        label.y = label.xy.y;
                    }
                    
                    if (s.options.DisplayColor && s.options.DisplayColor !== '#FFFFFF') {
                        var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', '0');
                        rect.setAttribute('y', tick.gridLine.getBBox().y - 1);
                        rect.setAttribute('z', 19);
                        rect.setAttribute('height', tick.axis.height / tick.axis.max);
                        rect.setAttribute('width', tick.getPosition().x);
                        rect.setAttribute("fill", hexToRgbA(s.options.DisplayColor, 0.2));
                        rect.setAttribute("labelfor", s.options.ObjectID);
                        label.element.parentElement.appendChild(rect);
                        Ext.get(rect).on('click', tick.axis.chart.yAxis[0].options.labels.events.click);
                        //label.element.relayEvents(rect, ['click']);
                    }
                }
            },

            _drawDependencies: function (dependencies) {
                var chart = this.chart.down('highchart').chart;
                var pairs = [];

                pairs.ExistsAlready = function (point) {
                    var existingLine = Ext.Array.filter(this, function (i) {
                        return ((i.startX === point.startX && i.startY === point.startY &&
                                i.endX === point.endX && i.endY === point.endY) ||
                            (i.startX === point.endX && i.startY === point.endY &&
                                i.endX === point.startX && i.endY === point.startY)
                        )
                    });
                    return existingLine.length !== 0;
                };

                function createPoint(start, end, type, color, id, markerEnd, markerStart) {
                    var startX = start.plotX + chart.plotBox.x;
                    var startY = start.plotY + chart.plotBox.y;
                    var endX = end.plotX + chart.plotBox.x;
                    var endY = end.plotY + chart.plotBox.y;

                    var isPredecessor = type === 'Predecessors';
                    if (start === end) {
                        if (isPredecessor) {
                            startX -= 30;
                            startY -= 10;
                            endX -= 10;
                        } else {
                            startX += start.shapeArgs.width + 30;
                            startY -= 10;
                            endX += end.shapeArgs.width;
                        }
                    } else {
                        if (isPredecessor) {
                            startX += start.shapeArgs.width;
                        } else {
                            endX += end.shapeArgs.width;
                        }
                    }
                    return {
                        startX: startX,
                        startY: startY,
                        endX: endX,
                        endY: endY,
                        moveTo: ['M', startX, startY],
                        draw: ['L', endX, endY],
                        config: {
                            'stroke-width': 2,
                            stroke: color,
                            id: id,
                            class: 'dependency',
                            type: type,
                            zIndex: 30,
                            'marker-end': markerEnd || 'none',
                            'marker-start': markerStart || 'none',
                        }
                    }
                }

                function FindByID(id) {
                    var p1 = Ext.Array.filter(chart.series, function (s) {
                        return s.options.ObjectID === id;
                    }, this);
                    if (p1 && p1[0] && p1[0].data && p1[0].data[0]) {
                        return p1[0].data[0];
                    }
                }

                Ext.Array.forEach(dependencies, function (v) {
                    var start = FindByID(v.item);
                    if (!start) return;
                    // dependency not in the queryable list
                    if (v.records.length === 0) {
                        var point = createPoint(start, start, v.type, '#660066', 'dependency-' +
                            v.item + '-UNKNOWN-', 'url(#dependencyMarker)',
                            'url(#unknownMarker)');
                        if (!pairs.ExistsAlready(point)) {
                            pairs.push(point);
                        }
                    }
                    Ext.Array.forEach(v.records, function (r) {
                        var end = FindByID(r.raw.ObjectID) || start;
                        var point = createPoint(start, end, v.type, '#660066',
                            'dependency-' + v.item + '-' + end.category + '-',
                            'url(#dependencyMarker)', 'url(#dependencyMarker)');
                        // check if a line already exists so we dont draw two - we use a double headed arrow  
                        if (!pairs.ExistsAlready(point)) {
                            pairs.push(point);
                        }
                    }, this);
                }, this);

                Ext.Array.forEach(pairs, function (p) {
                    chart.renderer.path(p.moveTo.concat(p.draw)).attr(p.config).add();
                });

                var dependencies = this.down("checkbox[fieldLabel='Dependencies']");
                this.onDependencyCheckboxChange.apply(this, [dependencies, dependencies.value]);
            },

            _getDependencies: function (portfolioItems) {
                this.onDependencyCheckboxChange.apply(this, [null, false]);

                var items = Ext.Array.filter(portfolioItems, function (i) {
                    return (i.raw.Predecessors.Count > 0 || i.raw.Successors.Count > 0);
                });
                if (items.length === 0) {
                    return;
                }

                this.dataLoader.GetDependencies({
                    config: {
                        items: items
                    },
                    success: function (values) {
                        this._drawDependencies.apply(this, arguments);
                    },
                    failure: function (error) {
                        this._showMask(error);
                    },
                    scope: this
                });
            },

            _loadData: function () {
                this._showMask('Loading...');

                this.dataLoader.LoadData({
                    success: function (values) {
                        var success = values[0] && values[1] && values[2] && values[3];
                        this._updateChart(success, values[0], values[1], [].concat(values[2],
                            values[3]));
                        this._hideMask();
                    },
                    failure: function (error) {
                        this._showMask(error);
                    },
                    scope: this
                }, {
                    portfolioItem: {
                        type: this.getSetting('Portfolio Item Type'),
                        limit: Ext.Number.from(this.getSetting('PortfolioItemLimit'), undefined),
                    },
                });
            },

            _categoryFormatter: function (portfolioItem) {
                return portfolioItem.raw.FormattedID + ': ' + portfolioItem.raw.Name;
            },

            _informationButtonClick: function() {
                var that = this;

                Ext.create('Rally.ui.dialog.Dialog', {
                    autoShow: true,
                    draggable: true,
                    closable: true,
                    width: 400,
                    title: 'Information',
                    items: {
                        xtype: 'component',
                        html: '' + 
                            '<div style="width: 100%;">' +
                            '<div>Choose either Portfolio Item or Features</div>' +
                            '<div>Red = planned</div>' +
                            '<div>Blue = actual</div>' +
                            '<div>Black = no planned dates enter, so created date used</div>' +
                            '</div>',
                        padding: 10
                    },
                    listeners: {
                        close: function (e, o) {
                            that._showMask("Refreshing...");
                            that._loadData.apply(that);
                        }
                    }
                });
            },

            _addButton: function () {
                var that = this;
                var button = Ext.create('Rally.ui.Button', {
                    text: 'Information',
                    handler: function () {
                        that._informationButtonClick.apply(that, arguments);
                    },
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        'z-index': 199
                    }
                });
                that.add(button);
            },

            onTimeboxCheckboxChange: function (checkBox, newValue) {
                var app = Rally.getApp();
                if (!checkBox) {
                    return;
                }
                var isIteration = checkBox.fieldLabel === 'Iterations';

                if (app.chart.down('highchart').chart) {
                    Ext.Array.each(app.chart.down('highchart').chart.xAxis[0].plotLinesAndBands,
                        function (band) {
                            if (isIteration === band.options.isIteration && band.svgElem && band.label) {
                                if (newValue) {
                                    band.svgElem.show();
                                    band.label.show();
                                } else {
                                    band.svgElem.hide();
                                    band.label.hide();
                                }
                            }
                        }, app);
                }
            },

            onDependencyCheckboxChange: function (checkBox, newValue) {
                var app = Rally.getApp();
                if (app.chart.down('highchart').chart) {
                    Ext.Array.each(app.chart.down('highchart').chart.renderer.box.getElementsByClassName(
                            "dependency"),
                        function (path) {
                            path.style.visibility = newValue ? "visible" : "hidden";
                        }, app);
                }
            },

            _addChecks: function () {
                var releaseCheck = Ext.create('Rally.ui.CheckboxField', {
                    fieldLabel: 'Releases',
                    value: true,
                    listeners: {
                        change: this.onTimeboxCheckboxChange,
                    },
                    labelAlign: 'right',
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 80,
                        width: '80px',
                        'z-index': 199
                    }
                });
                this.add(releaseCheck);

                var iterationCheck = Ext.create('Rally.ui.CheckboxField', {
                    fieldLabel: 'Iterations',
                    value: true,
                    listeners: {
                        change: this.onTimeboxCheckboxChange,
                    },
                    labelAlign: 'right',
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 200,
                        width: '80px',
                        'z-index': 199
                    }
                });
                this.add(iterationCheck);

                var dependenciesCheck = Ext.create('Rally.ui.CheckboxField', {
                    fieldLabel: 'Dependencies',
                    value: true,
                    listeners: {
                        change: this.onDependencyCheckboxChange,
                    },
                    labelAlign: 'right',
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 335,
                        width: '80px',
                        'z-index': 199
                    }
                });
                this.add(dependenciesCheck);
            },

            _yAxisLabelClick: function (label, series, evt) {
                // open item
                var context = Rally.environment.getContext();
                var currentProjectOid = Rally.util.Ref.getOidFromRef(context.getProject()._ref);
                var type = Rally.getApp().getSetting('Portfolio Item Type');
                var objectID;
                try { objectID = this.getAttribute('labelfor'); }
                catch (e) { objectID = label.element.getAttribute("labelfor"); }
                if (objectID === "undefined") objectID = undefined;
                if (!objectID) return;
                var url = '/#/' 
                    + Rally.environment.getContext().getScopeStr(null) 
                    + '/detail' 
                    + Rally.util.Ref.getRefFromTypeAndOid(type, objectID);
                console.log(url);
                window.top.document.location = url;
            },

            _chartConfig: function (plotBands, categories, series) {
                var rowHeight = 32;
                var height = ((series.length + 2) * rowHeight);
                if (height < 100) height = 100;

                function axisOffset() {
                    var style = (function (style) {
                        return (style && style.indexOf("px") > -1) ? parseInt(style, 10) : 0;
                    })(this.axis.options.labels.style.fontSize);

                    var offset = (this.chart.plotHeight / this.chart.series.length / 2) - (style / -2)
                    if (this.axis.options.labels.y != offset) {
                        this.axis.options.labels.y = offset;
                    }
                }

                return {
                    chart: {
                        type: 'xrange',
                        zoomType: 'x',
                        height: height,
                        spacingLeft: 170,
                    },
                    title: {
                        text: 'Timeline'
                    },
                    xAxis: {
                        opposite: true,
                        type: 'datetime',
                        minTickInterval: 7 * 24 * 3600 * 1000,
                        maxZoom: 7 * 24 * 3600 * 1000,
                        labels: {
                            formatter: function () {
                                return new Date(this.value).toLocaleDateString('en-AU');
                            },
                        },
                        plotLines: [{
                            value: Date.now(),
                            color: 'black',
                            width: 2,
                            id: 'plot-line-today',
                            zIndex: 10,
                        }],
                        plotBands: Ext.Array.filter(plotBands, function (pb) {
                            pb.events = {
                                click: function (event) {
                                    Rally.getApp().showTooltip.apply(this, [event,
                                        'Timebox'
                                    ]);
                                },
                                mouseout: function () {
                                    Ext.defer(function () {
                                        this.hideTooltip.apply(this, arguments);
                                    }, 5000, Rally.getApp(), arguments);
                                },
                            };
                            return pb;
                        }),
                    },
                    yAxis: [{
                        title: 'Items',
                        tickInterval: 1,
                        tickmarkPlacement: 'between',
                        margin: 20,
                        categories: categories,
                        labels: {
                            style: {
                                width: '170px',
                                height: rowHeight + 'px',
                                'text-align': 'left',
                                top: 0,
                                left: 0,
                            },
                            formatter: function () {
                                var label = this.axis.defaultLabelFormatter.call(this);
                                return label.length > 45 ? label.substring(0, 45) +
                                    '\u2026' : label;
                            },
                            align: 'left',
                            x: -170,
                            events: {
                                click: this._yAxisLabelClick,
                            },
                        },
                    }, {
                        title: 'Milestone',
                        gridLineColor: 'transparent',
                        labels: {
                            enabled: false,
                        },
                    }],
                    legend: {
                        enabled: false,
                    },
                    plotOptions: {
                        series: {
                            pointWidth: 10,
                            minPointLength: 5,
                            dataLabels: true,
                            point: {
                                events: {
                                    click: function (event) {
                                        Ext.defer(function (event) {
                                            this.showTooltip.apply(this, [event,
                                                event.currentTarget.series.yAxis.userOptions.title
                                            ]);
                                        }, 200, Rally.getApp(), [event]);
                                    }
                                }
                            },
                            events: {
                                mouseOut: function () {
                                    Ext.defer(function () {
                                        this.hideTooltip.apply(this, arguments);
                                    }, 5000, Rally.getApp(), arguments);
                                }
                            },
                        }
                    },
                    tooltip: {
                        enabled: false,
                    },
                }
            },

            AsUTC: function (d, backup) {
                var date = new Date(d);
                if (date.getUTCFullYear() < 2010) return backup ? this.AsUTC(backup) : undefined;
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            },

            _createPlotbandsFromTimeboxes: function (timeboxes) {
                // restructure the timeboxes
                var plotBands = [];
                var steps = Math.round(timeboxes.length / 1);
                var frequency = 2 * Math.PI / steps,
                    phase1 = 0,
                    phase2 = 2,
                    phase3 = 4,
                    center = 200;
                var width = 255 - center;

                Ext.each(timeboxes, function (tb) {
                    var timebox = tb.raw;
                    var isIteration = timebox._type === 'Iteration';

                    var i;
                    if (timeboxes.length % 4 === 0) { // otherwise 4224 and colours are beside each other
                        i = plotBands.length + 1;
                    } else {
                        i = plotBands.length % 2 === 0 ? plotBands.length + 1 : timeboxes.length - plotBands.length + 1;
                    }

                    var red = Math.round(Math.sin(frequency * i + phase1) * width + center);
                    var grn = Math.round(Math.sin(frequency * i + phase2) * width + center);
                    var blu = Math.round(Math.sin(frequency * i + phase3) * width + center);
                    var color = 'rgba(' + red + ', ' + grn + ', ' + blu + ', 0.25)';

                    plotBands.push({
                        color: color,
                        from: this.AsUTC(timebox.StartDate || timebox.ReleaseStartDate),
                        to: this.AsUTC(timebox.EndDate || timebox.ReleaseDate),
                        zIndex: isIteration ? 1 : 0,
                        isIteration: isIteration,
                        label: {
                            text: timebox.Name,
                            textAlign: 'left',
                            rotation: 90,
                            data: {
                                theme: timebox.Theme,
                                type: timebox._type,
                            },
                            borderColor: '#666',
                            borderWidth: 1,
                            style: {
                                color: '#666',
                            },
                            zIndex: isIteration ? 11 : 10,
                        },
                    });
                }, this);
                return plotBands;
            },

            _createSeriesFromPortfolioItems: function (categories, portfolioItems) {
                // restructure the portfolioItems
                var series = [];
                Ext.each(portfolioItems, function (t) {
                    var portfolioItem = t.raw;
                    var item = {
                        type: 'column',
                        yAxis: 0,
                        name: portfolioItem.Name,
                        ObjectID: portfolioItem.ObjectID,
                        DisplayColor: portfolioItem.DisplayColor,
                        data: []
                    };
                    if (this.AsUTC(portfolioItem.PlannedStartDate) && this.AsUTC(portfolioItem.PlannedEndDate)) {
                        item.data.push({
                            x: this.AsUTC(portfolioItem.PlannedStartDate),
                            x2: this.AsUTC(portfolioItem.PlannedEndDate),
                            y: categories.indexOf(this._categoryFormatter(t)),
                            label: portfolioItem.Description,
                            color: 'red',
                            height: 20,
                            zIndex: 1,
                            ObjectID: portfolioItem.ObjectID,
                        });
                    } else if (this.AsUTC(portfolioItem.CreationDate) && this.AsUTC(portfolioItem.CreationDate)) {
                        item.data.push({
                            x: this.AsUTC(portfolioItem.CreationDate),
                            x2: this.AsUTC(portfolioItem.CreationDate),
                            y: categories.indexOf(this._categoryFormatter(t)),
                            label: '<b>NO PLANNED START/END SET</b><br>' +
                                portfolioItem.Description,
                            color: 'black',
                            height: 20,
                            zIndex: 1,
                            ObjectID: portfolioItem.ObjectID,
                        });
                    }
                    if (this.AsUTC(portfolioItem.ActualStartDate)) {
                        item.data.push({
                            x: this.AsUTC(portfolioItem.ActualStartDate),
                            x2: this.AsUTC(portfolioItem.ActualEndDate, Date.now()),
                            y: categories.indexOf(this._categoryFormatter(t)),
                            label: portfolioItem.Description,
                            color: 'blue',
                            height: 10,
                            zIndex: 2,
                            ObjectID: portfolioItem.ObjectID,
                        });
                    }
                    series.push(item);
                }, this);
                return series;
            },

            _createSeriesFromMilestones: function (milestones) {
                // restructure the milestones
                var series = [];
                var thisProject = this.getContext().getDataContext().project;
                Ext.each(milestones, function (m) {
                    var milestone = m.raw;
                    var item = {
                        type: 'scatter',
                        yAxis: 1,
                        name: milestone.Name,
                        color: milestone.DisplayColor,
                        marker: {
                            symbol: 'triangle-down',
                            lineWidth: 2,
                            lineColor: milestone.DisplayColor,
                            radius: 8
                        },
                        data: [{
                            x: this.AsUTC(milestone.TargetDate),
                            y: 1,
                            label: milestone.Notes,
                        }],
                    }
                    if (milestone.TargetProject._ref === thisProject && this.AsUTC(milestone.TargetDate)) {
                        series.push(item);
                    }
                }, this);

                return series;
            },
        });

        Rally.onReady(function () {
            if (Rally && Rally.sdk && Rally.sdk.dependencies && Rally.sdk.dependencies.Analytics) {
                Rally.sdk.dependencies.Analytics.load(function () {
                    window.Highcharts.defaultOptions = window.Highcharts.getOptions();
                    Ext.Loader.loadScript({
                        url: '//code.highcharts.com/modules/exporting.js',
                        onLoad: function () {
                            Rally.ExtendHighcharts(window.Highcharts);
                            Rally.launchApp('PortfolioTimelineExtendedApp', {
                                name: 'Portfolio Timeline Extended'
                            });
                        },
                        onError: function () {
                            console.log('error');
                        }
                    });
                }, this);
            }
        });

    })();
</script>