<html>
<head>
    <script>
(function (global) {

    'use strict';

    var $$iterator, ArrayIteratorPrototype;

    // don't trample native promises if they exist
    if ('Promise' in global && typeof global.Promise.all === 'function') {
        return;
    }

    // set a value as non-configurable and non-enumerable
    function defineInternal(obj, key, val) {
        Object.defineProperty(obj, key, {
            configurable: false,
            enumerable: false,
            writable: true,
            value: val
        });
    }

    // From the ES6 spec (http://people.mozilla.org/~jorendorff/es6-draft.html)

    // 6 ECMAScript Data Types and Values
    function Type(x) {
        switch (typeof x) {
            case 'undefined':
            case 'boolean':
            case 'string':
            case 'number':
                return typeof x;
            default:
                if (x === null) {
                    return 'null';
                }
                if (typeof Symbol === 'function' && x instanceof Symbol) {
                    return 'symbol';
                }
                return 'object';
        }
    }

    // 6.1.5.1 Well-Known Symbols (iterator key)
    $$iterator = typeof Symbol !== 'undefined' && Symbol.iterator ||
      '_shim_iterator_';

    // 7.1.4 ToInteger
    function ToInteger(argument) {
        var number = +argument;
        if (number !== number) {
            return 0;
        }
        if (number === 0 || number === Infinity || number === -Infinity) {
            return number;
        }
        return (number >= 0 ? 1 : -1) * Math.floor(Math.abs(number));
    }

    // 7.1.12 ToString
    function ToString(argument) {
        return typeof argument === 'string' ? argument : String(argument);
    }

    // 7.1.13 ToObject
    function ToObject(argument) {
        if (argument == null) {
            throw TypeError();
        }
        switch (typeof argument) {
            case 'boolean':
            case 'number':
            case 'string':
                return Object(argument);
            default:
                return argument;
        }
    }

    // 7.1.15 ToLength
    function ToLength(argument) {
        var len = ToInteger(argument);
        return len <= 0 ? 0 : Math.min(len, Math.pow(2, 53) - 1);
    }

    // 7.2.2 IsCallable
    function IsCallable(argument) {
        return typeof argument === 'function';
    }

    // 7.2.3 SameValue( x, y )
    function SameValue(x, y) {
        if (typeof x !== typeof y) {
            return false;
        }
        if (Type(x) === 'undefined') {
            return true;
        }
        if (Type(x) === 'number') {
            if (x !== x && y !== y) {
                return true;
            }
            if (x === 0) {
                return 1 / x === 1 / y;
            }
        }
        return x === y;
    }

    // 7.2.5 IsConstructor
    // this is an ES6 abstract operation, and it's not really
    // possible in JS, but this should be good enough
    function IsConstructor(obj) {
        return typeof obj === 'function';
    }

    // 7.4.1 GetIterator ( obj )
    // not a real shim, but it works
    function GetIterator(obj) {
        var iterator = obj[$$iterator]();
        if (Type(obj) !== 'object') {
            throw TypeError();
        }
        return iterator;
    }

    // 7.4.2 IteratorNext ( iterator, value )
    function IteratorNext(iterator, value) {
        var result = iterator.next(value);
        if (Type(result) !== 'object') {
            throw TypeError();
        }
        return result;
    }

    // 7.4.3 IteratorComplete ( iterResult )
    function IteratorComplete(iterResult) {
        if (Type(iterResult) !== 'object') {
            throw TypeError();
        }
        return Boolean(iterResult.done);
    }

    // 7.4.4 IteratorValue ( iterResult )
    function IteratorValue(iterResult) {
        if (Type(iterResult) !== 'object') {
            throw TypeError();
        }
        return iterResult.value;
    }

    // 7.4.5 IteratorStep ( iterator )
    function IteratorStep(iterator) {
        var result = IteratorNext(iterator);
        return IteratorComplete(result) === true ? false : result;
    }

    // 7.4.6 CreateIterResultObject ( value, done )
    function CreateIterResultObject(value, done) {
        if (Type(done) !== 'boolean') {
            throw TypeError();
        }
        return { value: value, done: done };
    }

    // 8.4.1 EnqueueTask ( queueName, task, arguments)
    // not a real shim, but good enough
    function EnqueueTask(task, args) {
        if (typeof setImmediate === 'function') {
            setImmediate(function () {
                task.apply(null, args);
            });
        } else {
            setTimeout(function () {
                task.apply(null, args);
            }, 0);
        }
    }

    // 22.1.5.1 CreateArrayIterator Abstract Operation
    function CreateArrayIterator(array, kind) {
        var O = ToObject(array),
          iterator = Object.create(ArrayIteratorPrototype);
        defineInternal(iterator, '[[IteratedObject]]', O);
        defineInternal(iterator, '[[ArrayIteratorNextIndex]]', 0);
        defineInternal(iterator, '[[ArrayIteratorKind]]', kind);
        return iterator;
    }

    // 22.1.3.29 Array.prototype.values ( )
    Array.prototype.values = function () {
        var O = ToObject(this);
        return CreateArrayIterator(O, 'value');
    };

    // 22.1.3.30 Array.prototype [ @@iterator ] ( )
    Array.prototype[$$iterator] = Array.prototype.values;

    // 22.1.5.2 The %ArrayIteratorPrototype% Object
    ArrayIteratorPrototype = {};

    // 22.1.5.2.1 %ArrayIteratorPrototype%. next()
    ArrayIteratorPrototype.next = function () {
        var O = this, a, index, itemKind, lenValue, len,
          elementKey, elementValue, result;
        if (Type(O) !== 'object') {
            throw TypeError();
        }
        a = O['[[IteratedObject]]'];
        if (Type(a) === 'undefined') {
            return CreateIterResultObject(undefined, true);
        }
        index = O['[[ArrayIteratorNextIndex]]'];
        itemKind = O['[[ArrayIteratorKind]]'];
        lenValue = a.length;
        len = ToLength(lenValue);
        if (index >= len) {
            defineInternal(O, '[[IteratedObject]]', undefined);
            return CreateIterResultObject(undefined, true);
        }
        defineInternal(O, '[[ArrayIteratorNextIndex]]', index + 1);
        if (itemKind.indexOf('value') !== -1) {
            elementKey = ToString(index);
            elementValue = a[elementKey];
        }
        if (itemKind.indexOf('key+value') !== -1) {
            result = [index, elementValue];
            return CreateIterResultObject(result, false);
        } else if (itemKind.indexOf('key') !== -1) {
            return CreateIterResultObject(index, false);
        }
        if (itemKind.indexOf('value') === -1) {
            throw TypeError();
        }
        return CreateIterResultObject(elementValue, false);
    };

    // 22.1.5.2.2 %ArrayIteratorPrototype% [ @@iterator ] ( )
    ArrayIteratorPrototype[$$iterator] = function () {
        return this;
    };

    // 25.4.1.1.1 IfAbruptRejectPromise (value, capability)
    function IfAbruptRejectPromise(value, capability) {
        try {
            capability['[[Reject]]'].call(undefined, [value]);
        } catch (e) {
            return e;
        }
        return capability;
    }

    // 25.4.1.3 CreateRejectFunction ( promise )
    function CreateRejectFunction(promise) {
        var reject = new PromiseReject();
        defineInternal(reject, '[[Promise]]', promise);
        return reject;
    }

    // 25.4.1.3.1 Promise Reject Functions
    function PromiseReject() {
        return function F(reason) {
            var promise = F['[[Promise]]'], reactions;
            if (Type(promise) !== 'object') {
                throw TypeError();
            }
            if (promise['[[PromiseStatus]]'] !== 'unresolved') {
                return undefined;
            }
            reactions = promise['[[PromiseRejectReactions]]'];
            defineInternal(promise, '[[PromiseResult]]', reason);
            defineInternal(promise, '[[PromiseResolveReactions]]', undefined);
            defineInternal(promise, '[[PromiseRejectReactions]]', undefined);
            defineInternal(promise, '[[PromiseStatus]]', 'has-rejection');
            return TriggerPromiseReactions(reactions, reason);
        };
    }

    // 25.4.1.4 CreateRejectFunction ( promise )
    function CreateResolveFunction(promise) {
        var resolve = new PromiseResolve();
        defineInternal(resolve, '[[Promise]]', promise);
        return resolve;
    }

    // 25.4.1.4.1 Promise Resolve Functions
    function PromiseResolve() {
        return function F(resolution) {
            var promise = F['[[Promise]]'], reactions;
            if (Type(promise) !== 'object') {
                throw TypeError();
            }
            if (promise['[[PromiseStatus]]'] !== 'unresolved') {
                return undefined;
            }
            reactions = promise['[[PromiseResolveReactions]]'];
            defineInternal(promise, '[[PromiseResult]]', resolution);
            defineInternal(promise, '[[PromiseResolveReactions]]', undefined);
            defineInternal(promise, '[[PromiseRejectReactions]]', undefined);
            defineInternal(promise, '[[PromiseStatus]]', 'has-resolution');
            return TriggerPromiseReactions(reactions, resolution);
        };
    }

    // 25.4.1.5 NewPromiseCapability ( C )
    function NewPromiseCapability(C) {
        var promise;
        if (!IsConstructor(C)) {
            throw TypeError();
        }
        try {
            promise = Object.create(C.prototype);
        } catch (e) {
            return e;
        }
        return CreatePromiseCapabilityRecord(promise, C);
    }

    // 25.4.1.5.1 CreatePromiseCapabilityRecord( promise, constructor )
    function CreatePromiseCapabilityRecord(promise, constructor) {
        var promiseCapability = {}, executor, constructorResult;
        defineInternal(promiseCapability, '[[Promise]]', promise);
        defineInternal(promiseCapability, '[[Resolve]]', undefined);
        defineInternal(promiseCapability, '[[Reject]]', undefined);
        executor = new GetCapabilitiesExecutor();
        defineInternal(executor, '[[Capability]]', promiseCapability);
        try {
            constructorResult = constructor.call(promise, executor);
        } catch (e) {
            return e;
        }
        if (!IsCallable(promiseCapability['[[Resolve]]'])) {
            throw TypeError();
        }
        if (!IsCallable(promiseCapability['[[Reject]]'])) {
            throw TypeError();
        }
        if (typeof constructorResult === 'object' &&
          !SameValue(promise, constructorResult)) {
            throw TypeError();
        }
        return promiseCapability;
    }

    // 25.4.1.5.2 GetCapabilitiesExecutor Functions
    function GetCapabilitiesExecutor() {
        return function F(resolve, reject) {
            var promiseCapability = F['[[Capability]]'];
            if (Type(promiseCapability['[[Resolve]]']) !== 'undefined') {
                throw TypeError();
            }
            if (Type(promiseCapability['[[Reject]]']) !== 'undefined') {
                throw TypeError();
            }
            defineInternal(promiseCapability, '[[Resolve]]', resolve);
            defineInternal(promiseCapability, '[[Reject]]', reject);
        };
    }

    // 25.4.1.6 IsPromise ( x )
    function IsPromise(x) {
        if (Type(x) !== 'object') {
            return false;
        }
        if (Type(x['[[PromiseStatus]]']) === 'undefined') {
            return false;
        }
        return true;
    }

    // 25.4.1.7 TriggerPromiseReactions ( reactions, argument )
    function TriggerPromiseReactions(reactions, argument) {
        reactions.forEach(function (reaction) {
            EnqueueTask(PromiseReactionTask, [reaction, argument]);
        });
    }

    // 25.4.1.8 UpdatePromiseFromPotentialThenable ( x, promiseCapability )
    function UpdatePromiseFromPotentialThenable(x, promiseCapability) {
        var then, rejectResult, thenCallResult;
        if (Type(x) !== 'object') {
            return 'not a thenable';
        }
        try {
            then = x.then;
        } catch (e) {
            rejectResult = promiseCapability['[[Reject]]'].call(undefined, e);
            return null;
        }
        if (!IsCallable(then)) {
            return 'not a thenable';
        }
        try {
            thenCallResult = then.call(x, promiseCapability['[[Resolve]]'],
              promiseCapability['[[Reject]]']
            );
        } catch (e) {
            rejectResult = promiseCapability['[[Reject]]'].call(undefined, e);
            return null;
        }
        return null;
    }

    // 25.4.2.1 PromiseReactionTask( reaction, argument )
    function PromiseReactionTask(reaction, argument) {
        var promiseCapability = reaction['[[Capabilities]]'],
          handler = reaction['[[Handler]]'],
          handlerResult, selfResolutionError, updateResult;
        try {
            handlerResult = handler.call(undefined, argument);
        } catch (e) {
            return promiseCapability['[[Reject]]'].call(undefined, e);
        }
        if (SameValue(handlerResult, promiseCapability['[[Promise]]'])) {
            selfResolutionError = TypeError();
            return promiseCapability['[[Reject]]']
              .call(undefined, selfResolutionError);
        }
        updateResult = UpdatePromiseFromPotentialThenable(handlerResult,
          promiseCapability
        );
        if (updateResult === 'not a thenable') {
            return promiseCapability['[[Resolve]]'].call(undefined, handlerResult);
        }
        return undefined;
    }

    // 25.4.3.1 Promise ( executor )
    function Promise(executor) {
        var promise = this;
        if (!IsCallable(executor)) {
            throw TypeError('Invalid executor');
        }
        if (Type(promise) !== 'object') {
            throw TypeError('Invalid promise');
        }
        if (Type(promise['[[PromiseStatus]]']) !== 'undefined') {
            throw TypeError();
        }
        defineInternal(this, '[[PromiseConstructor]]', Promise);
        return InitializePromise(promise, executor);
    }

    // 25.4.3.1.1 InitializePromise( promise, executor )
    function InitializePromise(promise, executor) {
        var resolve, reject, completion, status;
        if (Type(promise['[[PromiseStatus]]']) !== 'undefined') {
            throw TypeError();
        }
        if (!IsCallable(executor)) {
            throw TypeError();
        }
        defineInternal(promise, '[[PromiseStatus]]', 'unresolved');
        defineInternal(promise, '[[PromiseResolveReactions]]', []);
        defineInternal(promise, '[[PromiseRejectReactions]]', []);
        resolve = CreateResolveFunction(promise);
        reject = CreateRejectFunction(promise);
        try {
            completion = executor.call(undefined, resolve, reject);
        } catch (e) {
            try {
                status = reject.call(undefined, e);
            } catch (e) {
                return e;
            }
        }
        return promise;
    }

    // 25.4.4.1 Promise.all ( iterable )
    Promise.all = function (iterable) {
        var C = this, promiseCapability, iterator, values,
          remainingElementsCount, index, next, resolveResult,
          nextValue, nextPromise, resolveElement, result;
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        try {
            iterator = GetIterator(iterable);
        } catch (e) {
            return IfAbruptRejectPromise(e, promiseCapability);
        }
        values = [];
        remainingElementsCount = { '[[value]]': 0 };
        index = 0;
        while (true) {
            try {
                next = IteratorStep(iterator);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            if (next === false) {
                if (index === 0) {
                    try {
                        resolveResult = promiseCapability['[[Resolve]]']
                          .call(undefined, values);
                    } catch (e) {
                        return e;
                    }
                }
                return promiseCapability['[[Promise]]'];
            }
            try {
                nextValue = IteratorValue(next);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            try {
                nextPromise = C.cast(nextValue);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            resolveElement = new PromiseAllResolveElementFunction();
            defineInternal(resolveElement, '[[Index]]', index);
            defineInternal(resolveElement, '[[Values]]', values);
            defineInternal(resolveElement, '[[Capabilities]]', promiseCapability);
            defineInternal(resolveElement, '[[RemainingElements]]',
              remainingElementsCount
            );
            try {
                result = nextPromise.then(resolveElement,
                  promiseCapability['[[Reject]]']
                );
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            index++;
            remainingElementsCount['[[value]]']++;
        }
    };

    // 25.4.4.1.1 Promise.all Resolve Element Functions
    function PromiseAllResolveElementFunction() {
        return function F(x) {
            var index = F['[[Index]]'],
              values = F['[[Values]]'],
              promiseCapability = F['[[Capabilities]]'],
              remainingElementsCount = F['[[RemainingElements]]'];
            try {
                values[index] = x;
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            remainingElementsCount['[[value]]']--;
            if (remainingElementsCount['[[value]]'] === 0) {
                promiseCapability['[[Resolve]]'].call(undefined, values);
            }
            return undefined;
        };
    }

    // 25.4.4.2 Promise.cast ( x )
    Promise.cast = function (x) {
        var C = this,
          promiseCapability,
          resolveResult,
          constructor;
        if (IsPromise(x)) {
            constructor = x['[[PromiseConstructor]]'];
            if (SameValue(constructor, C)) {
                return x;
            }
        }
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        try {
            resolveResult = promiseCapability['[[Resolve]]'].call(undefined, x);
        } catch (e) {
            return e;
        }
        return promiseCapability['[[Promise]]'];
    };

    // 25.4.4.4 Promise.race ( iterable )
    Promise.race = function (iterable) {
        var C = this, promiseCapability, iterator, nextValue, nextPromise, next;
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        try {
            iterator = GetIterator(iterable);
        } catch (e) {
            return IfAbruptRejectPromise(e, promiseCapability);
        }
        while (true) {
            try {
                next = IteratorStep(iterator);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            if (next === false) {
                return promiseCapability['[[Promise]]'];
            }
            try {
                nextValue = IteratorValue(next);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            try {
                nextPromise = C.cast(nextValue);
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
            try {
                nextPromise.then(promiseCapability['[[Resolve]]'],
                  promiseCapability['[[Reject]]']
                );
            } catch (e) {
                return IfAbruptRejectPromise(e, promiseCapability);
            }
        }
    };

    // 25.4.4.5 Promise.reject ( r )
    Promise.reject = function (r) {
        var C = this, promiseCapability, rejectResult;
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        try {
            rejectResult = promiseCapability['[[Reject]]'].call(undefined, r);
        } catch (e) {
            return e;
        }
        return promiseCapability['[[Promise]]'];
    };

    // 25.4.4.6 Promise.resolve ( x )
    Promise.resolve = function (x) {
        var C = this, promiseCapability, resolveResult;
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        try {
            resolveResult = promiseCapability['[[Resolve]]'].call(undefined, x);
        } catch (e) {
            return e;
        }
        return promiseCapability['[[Promise]]'];
    };

    // 25.4.5.1 Promise.prototype.catch ( onRejected )
    Promise.prototype['catch'] = function (onRejected) {
        var promise = this;
        return promise.then(undefined, onRejected);
    };

    // 25.4.5.3 Promise.prototype.then ( onFulfilled , onRejected )
    Promise.prototype.then = function (onFulfilled, onRejected) {
        var promise = this,
          C, promiseCapability, rejectionHandler, fulfillmentHandler,
          resolutionHandler, resolveReaction, rejectReaction, resolution;
        if (!IsPromise(promise)) {
            throw TypeError();
        }
        try {
            C = promise.constructor;
        } catch (e) {
            return e;
        }
        try {
            promiseCapability = NewPromiseCapability(C);
        } catch (e) {
            return e;
        }
        if (IsCallable(onRejected)) {
            rejectionHandler = onRejected;
        } else {
            rejectionHandler = new ThrowerFunction();
        }
        if (IsCallable(onFulfilled)) {
            fulfillmentHandler = onFulfilled;
        } else {
            fulfillmentHandler = new IdentityFunction();
        }
        resolutionHandler = new PromiseResolutionHandlerFunction();
        defineInternal(resolutionHandler, '[[Promise]]', promise);
        defineInternal(resolutionHandler, '[[FulfillmentHandler]]',
          fulfillmentHandler
        );
        defineInternal(resolutionHandler, '[[RejectionHandler]]',
          rejectionHandler
        );
        resolveReaction = {
            '[[Capabilities]]': promiseCapability,
            '[[Handler]]': resolutionHandler
        };
        rejectReaction = {
            '[[Capabilities]]': promiseCapability,
            '[[Handler]]': rejectionHandler
        };
        if (promise['[[PromiseStatus]]'] === 'unresolved') {
            promise['[[PromiseResolveReactions]]'].push(resolveReaction);
            promise['[[PromiseRejectReactions]]'].push(rejectReaction);
        }
        if (promise['[[PromiseStatus]]'] === 'has-resolution') {
            resolution = promise['[[PromiseResult]]'];
            EnqueueTask(PromiseReactionTask, [resolveReaction, resolution]);
        }
        if (promise['[[PromiseStatus]]'] === 'has-rejection') {
            resolution = promise['[[PromiseResult]]'];
            EnqueueTask(PromiseReactionTask, [rejectReaction, resolution]);
        }
        return promiseCapability['[[Promise]]'];
    };

    // 25.4.5.3.1 Identity Functions
    function IdentityFunction() {
        return function F(x) {
            return x;
        };
    }

    // 25.4.5.3.2 PromiseResolutionHandlerFunctions
    function PromiseResolutionHandlerFunction() {
        return function F(x) {
            var promise = F['[[Promise]]'],
              fulfillmentHandler = F['[[FulfillmentHandler]]'],
              rejectionHandler = F['[[RejectionHandler]]'],
              selfResolutionError, C, promiseCapability, updateResult;
            if (SameValue(x, promise)) {
                selfResolutionError = TypeError();
                return rejectionHandler.call(undefined, selfResolutionError);
            }
            C = promise['[[PromiseConstructor]]'];
            try {
                promiseCapability = NewPromiseCapability(C);
            } catch (e) {
                return e;
            }
            try {
                updateResult = UpdatePromiseFromPotentialThenable(x,
                  promiseCapability
                );
            } catch (e) {
                return e;
            }
            if (updateResult !== 'not a thenable') {
                return promiseCapability['[[Promise]]'].then(fulfillmentHandler,
                  rejectionHandler
                );
            }
            return fulfillmentHandler.call(undefined, x);
        };
    }

    // 25.4.5.3.3 Thrower Functions
    function ThrowerFunction() {
        return function F(e) {
            throw e;
        };
    }

    // export the Promise constructor
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = Promise;
    } else {
        global.Promise = Promise;
    }

}(this));
    </script>
    <script>
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
        //Not using strict: uneven strict support in browsers, #392, and causes
        //problems with requirejs.exec()/transpiler plugins that may not be strict.
        /*jslint regexp: true, nomen: true, sloppy: true */
        /*global window, navigator, document, importScripts, setTimeout, opera */

        var requirejs, require, define;
        (function (global) {
            var req, s, head, baseElement, dataMain, src,
                interactiveScript, currentlyAddingScript, mainScript, subPath,
                version = '2.1.14',
                commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
                cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
                jsSuffixRegExp = /\.js$/,
                currDirRegExp = /^\.\//,
                op = Object.prototype,
                ostring = op.toString,
                hasOwn = op.hasOwnProperty,
                ap = Array.prototype,
                apsp = ap.splice,
                isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
                isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
                //PS3 indicates loaded and complete, but need to wait for complete
                //specifically. Sequence is 'loading', 'loaded', execution,
                // then 'complete'. The UA check is unfortunate, but not sure how
                //to feature test w/o causing perf issues.
                readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                              /^complete$/ : /^(complete|loaded)$/,
                defContextName = '_',
                //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
                isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
                contexts = {},
                cfg = {},
                globalDefQueue = [],
                useInteractive = false;

            function isFunction(it) {
                return ostring.call(it) === '[object Function]';
            }

            function isArray(it) {
                return ostring.call(it) === '[object Array]';
            }

            /**
             * Helper function for iterating over an array. If the func returns
             * a true value, it will break out of the loop.
             */
            function each(ary, func) {
                if (ary) {
                    var i;
                    for (i = 0; i < ary.length; i += 1) {
                        if (ary[i] && func(ary[i], i, ary)) {
                            break;
                        }
                    }
                }
            }

            /**
             * Helper function for iterating over an array backwards. If the func
             * returns a true value, it will break out of the loop.
             */
            function eachReverse(ary, func) {
                if (ary) {
                    var i;
                    for (i = ary.length - 1; i > -1; i -= 1) {
                        if (ary[i] && func(ary[i], i, ary)) {
                            break;
                        }
                    }
                }
            }

            function hasProp(obj, prop) {
                return hasOwn.call(obj, prop);
            }

            function getOwn(obj, prop) {
                return hasProp(obj, prop) && obj[prop];
            }

            /**
             * Cycles over properties in an object and calls a function for each
             * property value. If the function returns a truthy value, then the
             * iteration is stopped.
             */
            function eachProp(obj, func) {
                var prop;
                for (prop in obj) {
                    if (hasProp(obj, prop)) {
                        if (func(obj[prop], prop)) {
                            break;
                        }
                    }
                }
            }

            /**
             * Simple function to mix in properties from source into target,
             * but only if target does not already have a property of the same name.
             */
            function mixin(target, source, force, deepStringMixin) {
                if (source) {
                    eachProp(source, function (value, prop) {
                        if (force || !hasProp(target, prop)) {
                            if (deepStringMixin && typeof value === 'object' && value &&
                                !isArray(value) && !isFunction(value) &&
                                !(value instanceof RegExp)) {

                                if (!target[prop]) {
                                    target[prop] = {};
                                }
                                mixin(target[prop], value, force, deepStringMixin);
                            } else {
                                target[prop] = value;
                            }
                        }
                    });
                }
                return target;
            }

            //Similar to Function.prototype.bind, but the 'this' object is specified
            //first, since it is easier to read/figure out what 'this' will be.
            function bind(obj, fn) {
                return function () {
                    return fn.apply(obj, arguments);
                };
            }

            function scripts() {
                return document.getElementsByTagName('script');
            }

            function defaultOnError(err) {
                throw err;
            }

            //Allow getting a global that is expressed in
            //dot notation, like 'a.b.c'.
            function getGlobal(value) {
                if (!value) {
                    return value;
                }
                var g = global;
                each(value.split('.'), function (part) {
                    g = g[part];
                });
                return g;
            }

            /**
             * Constructs an error with a pointer to an URL with more information.
             * @param {String} id the error ID that maps to an ID on a web page.
             * @param {String} message human readable error.
             * @param {Error} [err] the original error, if there is one.
             *
             * @returns {Error}
             */
            function makeError(id, msg, err, requireModules) {
                var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
                e.requireType = id;
                e.requireModules = requireModules;
                if (err) {
                    e.originalError = err;
                }
                return e;
            }

            if (typeof define !== 'undefined') {
                //If a define is already in play via another AMD loader,
                //do not overwrite.
                return;
            }

            if (typeof requirejs !== 'undefined') {
                if (isFunction(requirejs)) {
                    //Do not overwrite an existing requirejs instance.
                    return;
                }
                cfg = requirejs;
                requirejs = undefined;
            }

            //Allow for a require config object
            if (typeof require !== 'undefined' && !isFunction(require)) {
                //assume it is a config object.
                cfg = require;
                require = undefined;
            }

            function newContext(contextName) {
                var inCheckLoaded, Module, context, handlers,
                    checkLoadedTimeoutId,
                    config = {
                        //Defaults. Do not set a default for map
                        //config to speed up normalize(), which
                        //will run faster if there is no default.
                        waitSeconds: 7,
                        baseUrl: './',
                        paths: {},
                        bundles: {},
                        pkgs: {},
                        shim: {},
                        config: {}
                    },
                    registry = {},
                    //registry of just enabled modules, to speed
                    //cycle breaking code when lots of modules
                    //are registered, but not activated.
                    enabledRegistry = {},
                    undefEvents = {},
                    defQueue = [],
                    defined = {},
                    urlFetched = {},
                    bundlesMap = {},
                    requireCounter = 1,
                    unnormalizedCounter = 1;

                /**
                 * Trims the . and .. from an array of path segments.
                 * It will keep a leading path segment if a .. will become
                 * the first path segment, to help with module name lookups,
                 * which act like paths, but can be remapped. But the end result,
                 * all paths that use this function should look normalized.
                 * NOTE: this method MODIFIES the input array.
                 * @param {Array} ary the array of path segments.
                 */
                function trimDots(ary) {
                    var i, part;
                    for (i = 0; i < ary.length; i++) {
                        part = ary[i];
                        if (part === '.') {
                            ary.splice(i, 1);
                            i -= 1;
                        } else if (part === '..') {
                            // If at the start, or previous value is still ..,
                            // keep them so that when converted to a path it may
                            // still work when converted to a path, even though
                            // as an ID it is less than ideal. In larger point
                            // releases, may be better to just kick out an error.
                            if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {
                                continue;
                            } else if (i > 0) {
                                ary.splice(i - 1, 2);
                                i -= 2;
                            }
                        }
                    }
                }

                /**
                 * Given a relative module name, like ./something, normalize it to
                 * a real name that can be mapped to a path.
                 * @param {String} name the relative name
                 * @param {String} baseName a real name that the name arg is relative
                 * to.
                 * @param {Boolean} applyMap apply the map config to the value. Should
                 * only be done if this normalization is for a dependency ID.
                 * @returns {String} normalized name
                 */
                function normalize(name, baseName, applyMap) {
                    var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                        foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                        baseParts = (baseName && baseName.split('/')),
                        map = config.map,
                        starMap = map && map['*'];

                    //Adjust any relative paths.
                    if (name) {
                        name = name.split('/');
                        lastIndex = name.length - 1;

                        // If wanting node ID compatibility, strip .js from end
                        // of IDs. Have to do this here, and not in nameToUrl
                        // because node allows either .js or non .js to map
                        // to same file.
                        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                            name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                        }

                        // Starts with a '.' so need the baseName
                        if (name[0].charAt(0) === '.' && baseParts) {
                            //Convert baseName to array, and lop off the last part,
                            //so that . matches that 'directory' and not name of the baseName's
                            //module. For instance, baseName of 'one/two/three', maps to
                            //'one/two/three.js', but we want the directory, 'one/two' for
                            //this normalization.
                            normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                            name = normalizedBaseParts.concat(name);
                        }

                        trimDots(name);
                        name = name.join('/');
                    }

                    //Apply map config if available.
                    if (applyMap && map && (baseParts || starMap)) {
                        nameParts = name.split('/');

                        outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                            nameSegment = nameParts.slice(0, i).join('/');

                            if (baseParts) {
                                //Find the longest baseName segment match in the config.
                                //So, do joins on the biggest to smallest lengths of baseParts.
                                for (j = baseParts.length; j > 0; j -= 1) {
                                    mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                                    //baseName segment has config, find if it has one for
                                    //this name.
                                    if (mapValue) {
                                        mapValue = getOwn(mapValue, nameSegment);
                                        if (mapValue) {
                                            //Match, update name to the new value.
                                            foundMap = mapValue;
                                            foundI = i;
                                            break outerLoop;
                                        }
                                    }
                                }
                            }

                            //Check for a star map match, but just hold on to it,
                            //if there is a shorter segment match later in a matching
                            //config, then favor over this star map.
                            if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                                foundStarMap = getOwn(starMap, nameSegment);
                                starI = i;
                            }
                        }

                        if (!foundMap && foundStarMap) {
                            foundMap = foundStarMap;
                            foundI = starI;
                        }

                        if (foundMap) {
                            nameParts.splice(0, foundI, foundMap);
                            name = nameParts.join('/');
                        }
                    }

                    // If the name points to a package's name, use
                    // the package main instead.
                    pkgMain = getOwn(config.pkgs, name);

                    return pkgMain ? pkgMain : name;
                }

                function removeScript(name) {
                    if (isBrowser) {
                        each(scripts(), function (scriptNode) {
                            if (scriptNode.getAttribute('data-requiremodule') === name &&
                                    scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                                scriptNode.parentNode.removeChild(scriptNode);
                                return true;
                            }
                        });
                    }
                }

                function hasPathFallback(id) {
                    var pathConfig = getOwn(config.paths, id);
                    if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                        //Pop off the first array value, since it failed, and
                        //retry
                        pathConfig.shift();
                        context.require.undef(id);

                        //Custom require that does not do map translation, since
                        //ID is "absolute", already mapped/resolved.
                        context.makeRequire(null, {
                            skipMap: true
                        })([id]);

                        return true;
                    }
                }

                //Turns a plugin!resource to [plugin, resource]
                //with the plugin being undefined if the name
                //did not have a plugin prefix.
                function splitPrefix(name) {
                    var prefix,
                        index = name ? name.indexOf('!') : -1;
                    if (index > -1) {
                        prefix = name.substring(0, index);
                        name = name.substring(index + 1, name.length);
                    }
                    return [prefix, name];
                }

                /**
                 * Creates a module mapping that includes plugin prefix, module
                 * name, and path. If parentModuleMap is provided it will
                 * also normalize the name via require.normalize()
                 *
                 * @param {String} name the module name
                 * @param {String} [parentModuleMap] parent module map
                 * for the module name, used to resolve relative names.
                 * @param {Boolean} isNormalized: is the ID already normalized.
                 * This is true if this call is done for a define() module ID.
                 * @param {Boolean} applyMap: apply the map config to the ID.
                 * Should only be true if this map is for a dependency.
                 *
                 * @returns {Object}
                 */
                function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
                    var url, pluginModule, suffix, nameParts,
                        prefix = null,
                        parentName = parentModuleMap ? parentModuleMap.name : null,
                        originalName = name,
                        isDefine = true,
                        normalizedName = '';

                    //If no name, then it means it is a require call, generate an
                    //internal name.
                    if (!name) {
                        isDefine = false;
                        name = '_@r' + (requireCounter += 1);
                    }

                    nameParts = splitPrefix(name);
                    prefix = nameParts[0];
                    name = nameParts[1];

                    if (prefix) {
                        prefix = normalize(prefix, parentName, applyMap);
                        pluginModule = getOwn(defined, prefix);
                    }

                    //Account for relative paths if there is a base name.
                    if (name) {
                        if (prefix) {
                            if (pluginModule && pluginModule.normalize) {
                                //Plugin is loaded, use its normalize method.
                                normalizedName = pluginModule.normalize(name, function (name) {
                                    return normalize(name, parentName, applyMap);
                                });
                            } else {
                                // If nested plugin references, then do not try to
                                // normalize, as it will not normalize correctly. This
                                // places a restriction on resourceIds, and the longer
                                // term solution is not to normalize until plugins are
                                // loaded and all normalizations to allow for async
                                // loading of a loader plugin. But for now, fixes the
                                // common uses. Details in #1131
                                normalizedName = name.indexOf('!') === -1 ?
                                                 normalize(name, parentName, applyMap) :
                                                 name;
                            }
                        } else {
                            //A regular module.
                            normalizedName = normalize(name, parentName, applyMap);

                            //Normalized name may be a plugin ID due to map config
                            //application in normalize. The map config values must
                            //already be normalized, so do not need to redo that part.
                            nameParts = splitPrefix(normalizedName);
                            prefix = nameParts[0];
                            normalizedName = nameParts[1];
                            isNormalized = true;

                            url = context.nameToUrl(normalizedName);
                        }
                    }

                    //If the id is a plugin id that cannot be determined if it needs
                    //normalization, stamp it with a unique ID so two matching relative
                    //ids that may conflict can be separate.
                    suffix = prefix && !pluginModule && !isNormalized ?
                             '_unnormalized' + (unnormalizedCounter += 1) :
                             '';

                    return {
                        prefix: prefix,
                        name: normalizedName,
                        parentMap: parentModuleMap,
                        unnormalized: !!suffix,
                        url: url,
                        originalName: originalName,
                        isDefine: isDefine,
                        id: (prefix ?
                                prefix + '!' + normalizedName :
                                normalizedName) + suffix
                    };
                }

                function getModule(depMap) {
                    var id = depMap.id,
                        mod = getOwn(registry, id);

                    if (!mod) {
                        mod = registry[id] = new context.Module(depMap);
                    }

                    return mod;
                }

                function on(depMap, name, fn) {
                    var id = depMap.id,
                        mod = getOwn(registry, id);

                    if (hasProp(defined, id) &&
                            (!mod || mod.defineEmitComplete)) {
                        if (name === 'defined') {
                            fn(defined[id]);
                        }
                    } else {
                        mod = getModule(depMap);
                        if (mod.error && name === 'error') {
                            fn(mod.error);
                        } else {
                            mod.on(name, fn);
                        }
                    }
                }

                function onError(err, errback) {
                    var ids = err.requireModules,
                        notified = false;

                    if (errback) {
                        errback(err);
                    } else {
                        each(ids, function (id) {
                            var mod = getOwn(registry, id);
                            if (mod) {
                                //Set error on module, so it skips timeout checks.
                                mod.error = err;
                                if (mod.events.error) {
                                    notified = true;
                                    mod.emit('error', err);
                                }
                            }
                        });

                        if (!notified) {
                            req.onError(err);
                        }
                    }
                }

                /**
                 * Internal method to transfer globalQueue items to this context's
                 * defQueue.
                 */
                function takeGlobalQueue() {
                    //Push all the globalDefQueue items into the context's defQueue
                    if (globalDefQueue.length) {
                        //Array splice in the values since the context code has a
                        //local var ref to defQueue, so cannot just reassign the one
                        //on context.
                        apsp.apply(defQueue,
                                   [defQueue.length, 0].concat(globalDefQueue));
                        globalDefQueue = [];
                    }
                }

                handlers = {
                    'require': function (mod) {
                        if (mod.require) {
                            return mod.require;
                        } else {
                            return (mod.require = context.makeRequire(mod.map));
                        }
                    },
                    'exports': function (mod) {
                        mod.usingExports = true;
                        if (mod.map.isDefine) {
                            if (mod.exports) {
                                return (defined[mod.map.id] = mod.exports);
                            } else {
                                return (mod.exports = defined[mod.map.id] = {});
                            }
                        }
                    },
                    'module': function (mod) {
                        if (mod.module) {
                            return mod.module;
                        } else {
                            return (mod.module = {
                                id: mod.map.id,
                                uri: mod.map.url,
                                config: function () {
                                    return getOwn(config.config, mod.map.id) || {};
                                },
                                exports: mod.exports || (mod.exports = {})
                            });
                        }
                    }
                };

                function cleanRegistry(id) {
                    //Clean up machinery used for waiting modules.
                    delete registry[id];
                    delete enabledRegistry[id];
                }

                function breakCycle(mod, traced, processed) {
                    var id = mod.map.id;

                    if (mod.error) {
                        mod.emit('error', mod.error);
                    } else {
                        traced[id] = true;
                        each(mod.depMaps, function (depMap, i) {
                            var depId = depMap.id,
                                dep = getOwn(registry, depId);

                            //Only force things that have not completed
                            //being defined, so still in the registry,
                            //and only if it has not been matched up
                            //in the module already.
                            if (dep && !mod.depMatched[i] && !processed[depId]) {
                                if (getOwn(traced, depId)) {
                                    mod.defineDep(i, defined[depId]);
                                    mod.check(); //pass false?
                                } else {
                                    breakCycle(dep, traced, processed);
                                }
                            }
                        });
                        processed[id] = true;
                    }
                }

                function checkLoaded() {
                    var err, usingPathFallback,
                        waitInterval = config.waitSeconds * 1000,
                        //It is possible to disable the wait interval by using waitSeconds of 0.
                        expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                        noLoads = [],
                        reqCalls = [],
                        stillLoading = false,
                        needCycleCheck = true;

                    //Do not bother if this call was a result of a cycle break.
                    if (inCheckLoaded) {
                        return;
                    }

                    inCheckLoaded = true;

                    //Figure out the state of all the modules.
                    eachProp(enabledRegistry, function (mod) {
                        var map = mod.map,
                            modId = map.id;

                        //Skip things that are not enabled or in error state.
                        if (!mod.enabled) {
                            return;
                        }

                        if (!map.isDefine) {
                            reqCalls.push(mod);
                        }

                        if (!mod.error) {
                            //If the module should be executed, and it has not
                            //been inited and time is up, remember it.
                            if (!mod.inited && expired) {
                                if (hasPathFallback(modId)) {
                                    usingPathFallback = true;
                                    stillLoading = true;
                                } else {
                                    noLoads.push(modId);
                                    removeScript(modId);
                                }
                            } else if (!mod.inited && mod.fetched && map.isDefine) {
                                stillLoading = true;
                                if (!map.prefix) {
                                    //No reason to keep looking for unfinished
                                    //loading. If the only stillLoading is a
                                    //plugin resource though, keep going,
                                    //because it may be that a plugin resource
                                    //is waiting on a non-plugin cycle.
                                    return (needCycleCheck = false);
                                }
                            }
                        }
                    });

                    if (expired && noLoads.length) {
                        //If wait time expired, throw error of unloaded modules.
                        err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                        err.contextName = context.contextName;
                        return onError(err);
                    }

                    //Not expired, check for a cycle.
                    if (needCycleCheck) {
                        each(reqCalls, function (mod) {
                            breakCycle(mod, {}, {});
                        });
                    }

                    //If still waiting on loads, and the waiting load is something
                    //other than a plugin resource, or there are still outstanding
                    //scripts, then just try back later.
                    if ((!expired || usingPathFallback) && stillLoading) {
                        //Something is still waiting to load. Wait for it, but only
                        //if a timeout is not already in effect.
                        if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                            checkLoadedTimeoutId = setTimeout(function () {
                                checkLoadedTimeoutId = 0;
                                checkLoaded();
                            }, 50);
                        }
                    }

                    inCheckLoaded = false;
                }

                Module = function (map) {
                    this.events = getOwn(undefEvents, map.id) || {};
                    this.map = map;
                    this.shim = getOwn(config.shim, map.id);
                    this.depExports = [];
                    this.depMaps = [];
                    this.depMatched = [];
                    this.pluginMaps = {};
                    this.depCount = 0;

                    /* this.exports this.factory
                       this.depMaps = [],
                       this.enabled, this.fetched
                    */
                };

                Module.prototype = {
                    init: function (depMaps, factory, errback, options) {
                        options = options || {};

                        //Do not do more inits if already done. Can happen if there
                        //are multiple define calls for the same module. That is not
                        //a normal, common case, but it is also not unexpected.
                        if (this.inited) {
                            return;
                        }

                        this.factory = factory;

                        if (errback) {
                            //Register for errors on this module.
                            this.on('error', errback);
                        } else if (this.events.error) {
                            //If no errback already, but there are error listeners
                            //on this module, set up an errback to pass to the deps.
                            errback = bind(this, function (err) {
                                this.emit('error', err);
                            });
                        }

                        //Do a copy of the dependency array, so that
                        //source inputs are not modified. For example
                        //"shim" deps are passed in here directly, and
                        //doing a direct modification of the depMaps array
                        //would affect that config.
                        this.depMaps = depMaps && depMaps.slice(0);

                        this.errback = errback;

                        //Indicate this module has be initialized
                        this.inited = true;

                        this.ignore = options.ignore;

                        //Could have option to init this module in enabled mode,
                        //or could have been previously marked as enabled. However,
                        //the dependencies are not known until init is called. So
                        //if enabled previously, now trigger dependencies as enabled.
                        if (options.enabled || this.enabled) {
                            //Enable this module and dependencies.
                            //Will call this.check()
                            this.enable();
                        } else {
                            this.check();
                        }
                    },

                    defineDep: function (i, depExports) {
                        //Because of cycles, defined callback for a given
                        //export can be called more than once.
                        if (!this.depMatched[i]) {
                            this.depMatched[i] = true;
                            this.depCount -= 1;
                            this.depExports[i] = depExports;
                        }
                    },

                    fetch: function () {
                        if (this.fetched) {
                            return;
                        }
                        this.fetched = true;

                        context.startTime = (new Date()).getTime();

                        var map = this.map;

                        //If the manager is for a plugin managed resource,
                        //ask the plugin to load it now.
                        if (this.shim) {
                            context.makeRequire(this.map, {
                                enableBuildCallback: true
                            })(this.shim.deps || [], bind(this, function () {
                                return map.prefix ? this.callPlugin() : this.load();
                            }));
                        } else {
                            //Regular dependency.
                            return map.prefix ? this.callPlugin() : this.load();
                        }
                    },

                    load: function () {
                        var url = this.map.url;

                        //Regular dependency.
                        if (!urlFetched[url]) {
                            urlFetched[url] = true;
                            context.load(this.map.id, url);
                        }
                    },

                    /**
                     * Checks if the module is ready to define itself, and if so,
                     * define it.
                     */
                    check: function () {
                        if (!this.enabled || this.enabling) {
                            return;
                        }

                        var err, cjsModule,
                            id = this.map.id,
                            depExports = this.depExports,
                            exports = this.exports,
                            factory = this.factory;

                        if (!this.inited) {
                            this.fetch();
                        } else if (this.error) {
                            this.emit('error', this.error);
                        } else if (!this.defining) {
                            //The factory could trigger another require call
                            //that would result in checking this module to
                            //define itself again. If already in the process
                            //of doing that, skip this work.
                            this.defining = true;

                            if (this.depCount < 1 && !this.defined) {
                                if (isFunction(factory)) {
                                    //If there is an error listener, favor passing
                                    //to that instead of throwing an error. However,
                                    //only do it for define()'d  modules. require
                                    //errbacks should not be called for failures in
                                    //their callbacks (#699). However if a global
                                    //onError is set, use that.
                                    if ((this.events.error && this.map.isDefine) ||
                                        req.onError !== defaultOnError) {
                                        try {
                                            exports = context.execCb(id, factory, depExports, exports);
                                        } catch (e) {
                                            err = e;
                                        }
                                    } else {
                                        exports = context.execCb(id, factory, depExports, exports);
                                    }

                                    // Favor return value over exports. If node/cjs in play,
                                    // then will not have a return value anyway. Favor
                                    // module.exports assignment over exports object.
                                    if (this.map.isDefine && exports === undefined) {
                                        cjsModule = this.module;
                                        if (cjsModule) {
                                            exports = cjsModule.exports;
                                        } else if (this.usingExports) {
                                            //exports already set the defined value.
                                            exports = this.exports;
                                        }
                                    }

                                    if (err) {
                                        err.requireMap = this.map;
                                        err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                        err.requireType = this.map.isDefine ? 'define' : 'require';
                                        return onError((this.error = err));
                                    }

                                } else {
                                    //Just a literal value
                                    exports = factory;
                                }

                                this.exports = exports;

                                if (this.map.isDefine && !this.ignore) {
                                    defined[id] = exports;

                                    if (req.onResourceLoad) {
                                        req.onResourceLoad(context, this.map, this.depMaps);
                                    }
                                }

                                //Clean up
                                cleanRegistry(id);

                                this.defined = true;
                            }

                            //Finished the define stage. Allow calling check again
                            //to allow define notifications below in the case of a
                            //cycle.
                            this.defining = false;

                            if (this.defined && !this.defineEmitted) {
                                this.defineEmitted = true;
                                this.emit('defined', this.exports);
                                this.defineEmitComplete = true;
                            }

                        }
                    },

                    callPlugin: function () {
                        var map = this.map,
                            id = map.id,
                            //Map already normalized the prefix.
                            pluginMap = makeModuleMap(map.prefix);

                        //Mark this as a dependency for this plugin, so it
                        //can be traced for cycles.
                        this.depMaps.push(pluginMap);

                        on(pluginMap, 'defined', bind(this, function (plugin) {
                            var load, normalizedMap, normalizedMod,
                                bundleId = getOwn(bundlesMap, this.map.id),
                                name = this.map.name,
                                parentName = this.map.parentMap ? this.map.parentMap.name : null,
                                localRequire = context.makeRequire(map.parentMap, {
                                    enableBuildCallback: true
                                });

                            //If current map is not normalized, wait for that
                            //normalized name to load instead of continuing.
                            if (this.map.unnormalized) {
                                //Normalize the ID if the plugin allows it.
                                if (plugin.normalize) {
                                    name = plugin.normalize(name, function (name) {
                                        return normalize(name, parentName, true);
                                    }) || '';
                                }

                                //prefix and name should already be normalized, no need
                                //for applying map config again either.
                                normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                              this.map.parentMap);
                                on(normalizedMap,
                                    'defined', bind(this, function (value) {
                                        this.init([], function () { return value; }, null, {
                                            enabled: true,
                                            ignore: true
                                        });
                                    }));

                                normalizedMod = getOwn(registry, normalizedMap.id);
                                if (normalizedMod) {
                                    //Mark this as a dependency for this plugin, so it
                                    //can be traced for cycles.
                                    this.depMaps.push(normalizedMap);

                                    if (this.events.error) {
                                        normalizedMod.on('error', bind(this, function (err) {
                                            this.emit('error', err);
                                        }));
                                    }
                                    normalizedMod.enable();
                                }

                                return;
                            }

                            //If a paths config, then just load that file instead to
                            //resolve the plugin, as it is built into that paths layer.
                            if (bundleId) {
                                this.map.url = context.nameToUrl(bundleId);
                                this.load();
                                return;
                            }

                            load = bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true
                                });
                            });

                            load.error = bind(this, function (err) {
                                this.inited = true;
                                this.error = err;
                                err.requireModules = [id];

                                //Remove temp unnormalized modules for this module,
                                //since they will never be resolved otherwise now.
                                eachProp(registry, function (mod) {
                                    if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                        cleanRegistry(mod.map.id);
                                    }
                                });

                                onError(err);
                            });

                            //Allow plugins to load other code without having to know the
                            //context or how to 'complete' the load.
                            load.fromText = bind(this, function (text, textAlt) {
                                /*jslint evil: true */
                                var moduleName = map.name,
                                    moduleMap = makeModuleMap(moduleName),
                                    hasInteractive = useInteractive;

                                //As of 2.1.0, support just passing the text, to reinforce
                                //fromText only being called once per resource. Still
                                //support old style of passing moduleName but discard
                                //that moduleName in favor of the internal ref.
                                if (textAlt) {
                                    text = textAlt;
                                }

                                //Turn off interactive script matching for IE for any define
                                //calls in the text, then turn it back on at the end.
                                if (hasInteractive) {
                                    useInteractive = false;
                                }

                                //Prime the system by creating a module instance for
                                //it.
                                getModule(moduleMap);

                                //Transfer any config to this other module.
                                if (hasProp(config.config, id)) {
                                    config.config[moduleName] = config.config[id];
                                }

                                try {
                                    req.exec(text);
                                } catch (e) {
                                    return onError(makeError('fromtexteval',
                                                     'fromText eval for ' + id +
                                                    ' failed: ' + e,
                                                     e,
                                                     [id]));
                                }

                                if (hasInteractive) {
                                    useInteractive = true;
                                }

                                //Mark this as a dependency for the plugin
                                //resource
                                this.depMaps.push(moduleMap);

                                //Support anonymous modules.
                                context.completeLoad(moduleName);

                                //Bind the value of that module to the value for this
                                //resource ID.
                                localRequire([moduleName], load);
                            });

                            //Use parentName here since the plugin's name is not reliable,
                            //could be some weird string with no path that actually wants to
                            //reference the parentName's path.
                            plugin.load(map.name, localRequire, load, config);
                        }));

                        context.enable(pluginMap, this);
                        this.pluginMaps[pluginMap.id] = pluginMap;
                    },

                    enable: function () {
                        enabledRegistry[this.map.id] = this;
                        this.enabled = true;

                        //Set flag mentioning that the module is enabling,
                        //so that immediate calls to the defined callbacks
                        //for dependencies do not trigger inadvertent load
                        //with the depCount still being zero.
                        this.enabling = true;

                        //Enable each dependency
                        each(this.depMaps, bind(this, function (depMap, i) {
                            var id, mod, handler;

                            if (typeof depMap === 'string') {
                                //Dependency needs to be converted to a depMap
                                //and wired up to this module.
                                depMap = makeModuleMap(depMap,
                                                       (this.map.isDefine ? this.map : this.map.parentMap),
                                                       false,
                                                       !this.skipMap);
                                this.depMaps[i] = depMap;

                                handler = getOwn(handlers, depMap.id);

                                if (handler) {
                                    this.depExports[i] = handler(this);
                                    return;
                                }

                                this.depCount += 1;

                                on(depMap, 'defined', bind(this, function (depExports) {
                                    this.defineDep(i, depExports);
                                    this.check();
                                }));

                                if (this.errback) {
                                    on(depMap, 'error', bind(this, this.errback));
                                }
                            }

                            id = depMap.id;
                            mod = registry[id];

                            //Skip special modules like 'require', 'exports', 'module'
                            //Also, don't call enable if it is already enabled,
                            //important in circular dependency cases.
                            if (!hasProp(handlers, id) && mod && !mod.enabled) {
                                context.enable(depMap, this);
                            }
                        }));

                        //Enable each plugin that is used in
                        //a dependency
                        eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                            var mod = getOwn(registry, pluginMap.id);
                            if (mod && !mod.enabled) {
                                context.enable(pluginMap, this);
                            }
                        }));

                        this.enabling = false;

                        this.check();
                    },

                    on: function (name, cb) {
                        var cbs = this.events[name];
                        if (!cbs) {
                            cbs = this.events[name] = [];
                        }
                        cbs.push(cb);
                    },

                    emit: function (name, evt) {
                        each(this.events[name], function (cb) {
                            cb(evt);
                        });
                        if (name === 'error') {
                            //Now that the error handler was triggered, remove
                            //the listeners, since this broken Module instance
                            //can stay around for a while in the registry.
                            delete this.events[name];
                        }
                    }
                };

                function callGetModule(args) {
                    //Skip modules already defined.
                    if (!hasProp(defined, args[0])) {
                        getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
                    }
                }

                function removeListener(node, func, name, ieName) {
                    //Favor detachEvent because of IE9
                    //issue, see attachEvent/addEventListener comment elsewhere
                    //in this file.
                    if (node.detachEvent && !isOpera) {
                        //Probably IE. If not it will throw an error, which will be
                        //useful to know.
                        if (ieName) {
                            node.detachEvent(ieName, func);
                        }
                    } else {
                        node.removeEventListener(name, func, false);
                    }
                }

                /**
                 * Given an event from a script node, get the requirejs info from it,
                 * and then removes the event listeners on the node.
                 * @param {Event} evt
                 * @returns {Object}
                 */
                function getScriptData(evt) {
                    //Using currentTarget instead of target for Firefox 2.0's sake. Not
                    //all old browsers will be supported, but this one was easy enough
                    //to support and still makes sense.
                    var node = evt.currentTarget || evt.srcElement;

                    //Remove the listeners once here.
                    removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
                    removeListener(node, context.onScriptError, 'error');

                    return {
                        node: node,
                        id: node && node.getAttribute('data-requiremodule')
                    };
                }

                function intakeDefines() {
                    var args;

                    //Any defined modules in the global queue, intake them now.
                    takeGlobalQueue();

                    //Make sure any remaining defQueue items get properly processed.
                    while (defQueue.length) {
                        args = defQueue.shift();
                        if (args[0] === null) {
                            return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                        } else {
                            //args are id, deps, factory. Should be normalized by the
                            //define() function.
                            callGetModule(args);
                        }
                    }
                }

                context = {
                    config: config,
                    contextName: contextName,
                    registry: registry,
                    defined: defined,
                    urlFetched: urlFetched,
                    defQueue: defQueue,
                    Module: Module,
                    makeModuleMap: makeModuleMap,
                    nextTick: req.nextTick,
                    onError: onError,

                    /**
                     * Set a configuration for the context.
                     * @param {Object} cfg config object to integrate.
                     */
                    configure: function (cfg) {
                        //Make sure the baseUrl ends in a slash.
                        if (cfg.baseUrl) {
                            if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                                cfg.baseUrl += '/';
                            }
                        }

                        //Save off the paths since they require special processing,
                        //they are additive.
                        var shim = config.shim,
                            objs = {
                                paths: true,
                                bundles: true,
                                config: true,
                                map: true
                            };

                        eachProp(cfg, function (value, prop) {
                            if (objs[prop]) {
                                if (!config[prop]) {
                                    config[prop] = {};
                                }
                                mixin(config[prop], value, true, true);
                            } else {
                                config[prop] = value;
                            }
                        });

                        //Reverse map the bundles
                        if (cfg.bundles) {
                            eachProp(cfg.bundles, function (value, prop) {
                                each(value, function (v) {
                                    if (v !== prop) {
                                        bundlesMap[v] = prop;
                                    }
                                });
                            });
                        }

                        //Merge shim
                        if (cfg.shim) {
                            eachProp(cfg.shim, function (value, id) {
                                //Normalize the structure
                                if (isArray(value)) {
                                    value = {
                                        deps: value
                                    };
                                }
                                if ((value.exports || value.init) && !value.exportsFn) {
                                    value.exportsFn = context.makeShimExports(value);
                                }
                                shim[id] = value;
                            });
                            config.shim = shim;
                        }

                        //Adjust packages if necessary.
                        if (cfg.packages) {
                            each(cfg.packages, function (pkgObj) {
                                var location, name;

                                pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                                name = pkgObj.name;
                                location = pkgObj.location;
                                if (location) {
                                    config.paths[name] = pkgObj.location;
                                }

                                //Save pointer to main module ID for pkg name.
                                //Remove leading dot in main, so main paths are normalized,
                                //and remove any trailing .js, since different package
                                //envs have different conventions: some use a module name,
                                //some use a file name.
                                config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                             .replace(currDirRegExp, '')
                                             .replace(jsSuffixRegExp, '');
                            });
                        }

                        //If there are any "waiting to execute" modules in the registry,
                        //update the maps for them, since their info, like URLs to load,
                        //may have changed.
                        eachProp(registry, function (mod, id) {
                            //If module already has init called, since it is too
                            //late to modify them, and ignore unnormalized ones
                            //since they are transient.
                            if (!mod.inited && !mod.map.unnormalized) {
                                mod.map = makeModuleMap(id);
                            }
                        });

                        //If a deps array or a config callback is specified, then call
                        //require with those args. This is useful when require is defined as a
                        //config object before require.js is loaded.
                        if (cfg.deps || cfg.callback) {
                            context.require(cfg.deps || [], cfg.callback);
                        }
                    },

                    makeShimExports: function (value) {
                        function fn() {
                            var ret;
                            if (value.init) {
                                ret = value.init.apply(global, arguments);
                            }
                            return ret || (value.exports && getGlobal(value.exports));
                        }
                        return fn;
                    },

                    makeRequire: function (relMap, options) {
                        options = options || {};

                        function localRequire(deps, callback, errback) {
                            var id, map, requireMod;

                            if (options.enableBuildCallback && callback && isFunction(callback)) {
                                callback.__requireJsBuild = true;
                            }

                            if (typeof deps === 'string') {
                                if (isFunction(callback)) {
                                    //Invalid call
                                    return onError(makeError('requireargs', 'Invalid require call'), errback);
                                }

                                //If require|exports|module are requested, get the
                                //value for them from the special handlers. Caveat:
                                //this only works while module is being defined.
                                if (relMap && hasProp(handlers, deps)) {
                                    return handlers[deps](registry[relMap.id]);
                                }

                                //Synchronous access to one module. If require.get is
                                //available (as in the Node adapter), prefer that.
                                if (req.get) {
                                    return req.get(context, deps, relMap, localRequire);
                                }

                                //Normalize module name, if it contains . or ..
                                map = makeModuleMap(deps, relMap, false, true);
                                id = map.id;

                                if (!hasProp(defined, id)) {
                                    return onError(makeError('notloaded', 'Module name "' +
                                                id +
                                                '" has not been loaded yet for context: ' +
                                                contextName +
                                                (relMap ? '' : '. Use require([])')));
                                }
                                return defined[id];
                            }

                            //Grab defines waiting in the global queue.
                            intakeDefines();

                            //Mark all the dependencies as needing to be loaded.
                            context.nextTick(function () {
                                //Some defines could have been added since the
                                //require call, collect them.
                                intakeDefines();

                                requireMod = getModule(makeModuleMap(null, relMap));

                                //Store if map config should be applied to this require
                                //call for dependencies.
                                requireMod.skipMap = options.skipMap;

                                requireMod.init(deps, callback, errback, {
                                    enabled: true
                                });

                                checkLoaded();
                            });

                            return localRequire;
                        }

                        mixin(localRequire, {
                            isBrowser: isBrowser,

                            /**
                             * Converts a module name + .extension into an URL path.
                             * *Requires* the use of a module name. It does not support using
                             * plain URLs like nameToUrl.
                             */
                            toUrl: function (moduleNamePlusExt) {
                                var ext,
                                    index = moduleNamePlusExt.lastIndexOf('.'),
                                    segment = moduleNamePlusExt.split('/')[0],
                                    isRelative = segment === '.' || segment === '..';

                                //Have a file extension alias, and it is not the
                                //dots from a relative path.
                                if (index !== -1 && (!isRelative || index > 1)) {
                                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                                }

                                return context.nameToUrl(normalize(moduleNamePlusExt,
                                                        relMap && relMap.id, true), ext, true);
                            },

                            defined: function (id) {
                                return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                            },

                            specified: function (id) {
                                id = makeModuleMap(id, relMap, false, true).id;
                                return hasProp(defined, id) || hasProp(registry, id);
                            }
                        });

                        //Only allow undef on top level require calls
                        if (!relMap) {
                            localRequire.undef = function (id) {
                                //Bind any waiting define() calls to this context,
                                //fix for #408
                                takeGlobalQueue();

                                var map = makeModuleMap(id, relMap, true),
                                    mod = getOwn(registry, id);

                                removeScript(id);

                                delete defined[id];
                                delete urlFetched[map.url];
                                delete undefEvents[id];

                                //Clean queued defines too. Go backwards
                                //in array so that the splices do not
                                //mess up the iteration.
                                eachReverse(defQueue, function (args, i) {
                                    if (args[0] === id) {
                                        defQueue.splice(i, 1);
                                    }
                                });

                                if (mod) {
                                    //Hold on to listeners in case the
                                    //module will be attempted to be reloaded
                                    //using a different config.
                                    if (mod.events.defined) {
                                        undefEvents[id] = mod.events;
                                    }

                                    cleanRegistry(id);
                                }
                            };
                        }

                        return localRequire;
                    },

                    /**
                     * Called to enable a module if it is still in the registry
                     * awaiting enablement. A second arg, parent, the parent module,
                     * is passed in for context, when this method is overridden by
                     * the optimizer. Not shown here to keep code compact.
                     */
                    enable: function (depMap) {
                        var mod = getOwn(registry, depMap.id);
                        if (mod) {
                            getModule(depMap).enable();
                        }
                    },

                    /**
                     * Internal method used by environment adapters to complete a load event.
                     * A load event could be a script load or just a load pass from a synchronous
                     * load call.
                     * @param {String} moduleName the name of the module to potentially complete.
                     */
                    completeLoad: function (moduleName) {
                        var found, args, mod,
                            shim = getOwn(config.shim, moduleName) || {},
                            shExports = shim.exports;

                        takeGlobalQueue();

                        while (defQueue.length) {
                            args = defQueue.shift();
                            if (args[0] === null) {
                                args[0] = moduleName;
                                //If already found an anonymous module and bound it
                                //to this name, then this is some other anon module
                                //waiting for its completeLoad to fire.
                                if (found) {
                                    break;
                                }
                                found = true;
                            } else if (args[0] === moduleName) {
                                //Found matching define call for this script!
                                found = true;
                            }

                            callGetModule(args);
                        }

                        //Do this after the cycle of callGetModule in case the result
                        //of those calls/init calls changes the registry.
                        mod = getOwn(registry, moduleName);

                        if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                            if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                                if (hasPathFallback(moduleName)) {
                                    return;
                                } else {
                                    return onError(makeError('nodefine',
                                                     'No define call for ' + moduleName,
                                                     null,
                                                     [moduleName]));
                                }
                            } else {
                                //A script that does not call define(), so just simulate
                                //the call for it.
                                callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                            }
                        }

                        checkLoaded();
                    },

                    /**
                     * Converts a module name to a file path. Supports cases where
                     * moduleName may actually be just an URL.
                     * Note that it **does not** call normalize on the moduleName,
                     * it is assumed to have already been normalized. This is an
                     * internal API, not a public one. Use toUrl for the public API.
                     */
                    nameToUrl: function (moduleName, ext, skipExt) {
                        var paths, syms, i, parentModule, url,
                            parentPath, bundleId,
                            pkgMain = getOwn(config.pkgs, moduleName);

                        if (pkgMain) {
                            moduleName = pkgMain;
                        }

                        bundleId = getOwn(bundlesMap, moduleName);

                        if (bundleId) {
                            return context.nameToUrl(bundleId, ext, skipExt);
                        }

                        //If a colon is in the URL, it indicates a protocol is used and it is just
                        //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                        //or ends with .js, then assume the user meant to use an url and not a module id.
                        //The slash is important for protocol-less URLs as well as full paths.
                        if (req.jsExtRegExp.test(moduleName)) {
                            //Just a plain path, not module name lookup, so just return it.
                            //Add extension if it is included. This is a bit wonky, only non-.js things pass
                            //an extension, this method probably needs to be reworked.
                            url = moduleName + (ext || '');
                        } else {
                            //A module that needs to be converted to a path.
                            paths = config.paths;

                            syms = moduleName.split('/');
                            //For each module name segment, see if there is a path
                            //registered for it. Start with most specific name
                            //and work up from it.
                            for (i = syms.length; i > 0; i -= 1) {
                                parentModule = syms.slice(0, i).join('/');

                                parentPath = getOwn(paths, parentModule);
                                if (parentPath) {
                                    //If an array, it means there are a few choices,
                                    //Choose the one that is desired
                                    if (isArray(parentPath)) {
                                        parentPath = parentPath[0];
                                    }
                                    syms.splice(0, i, parentPath);
                                    break;
                                }
                            }

                            //Join the path parts together, then figure out if baseUrl is needed.
                            url = syms.join('/');
                            url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                            url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                        }

                        return config.urlArgs ? url +
                                                ((url.indexOf('?') === -1 ? '?' : '&') +
                                                 config.urlArgs) : url;
                    },

                    //Delegates to req.load. Broken out as a separate function to
                    //allow overriding in the optimizer.
                    load: function (id, url) {
                        req.load(context, id, url);
                    },

                    /**
                     * Executes a module callback function. Broken out as a separate function
                     * solely to allow the build system to sequence the files in the built
                     * layer in the right sequence.
                     *
                     * @private
                     */
                    execCb: function (name, callback, args, exports) {
                        return callback.apply(exports, args);
                    },

                    /**
                     * callback for script loads, used to check status of loading.
                     *
                     * @param {Event} evt the event from the browser for the script
                     * that was loaded.
                     */
                    onScriptLoad: function (evt) {
                        //Using currentTarget instead of target for Firefox 2.0's sake. Not
                        //all old browsers will be supported, but this one was easy enough
                        //to support and still makes sense.
                        if (evt.type === 'load' ||
                                (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                            //Reset interactive script so a script node is not held onto for
                            //to long.
                            interactiveScript = null;

                            //Pull out the name of the module and the context.
                            var data = getScriptData(evt);
                            context.completeLoad(data.id);
                        }
                    },

                    /**
                     * Callback for script errors.
                     */
                    onScriptError: function (evt) {
                        var data = getScriptData(evt);
                        if (!hasPathFallback(data.id)) {
                            return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                        }
                    }
                };

                context.require = context.makeRequire();
                return context;
            }

            /**
             * Main entry point.
             *
             * If the only argument to require is a string, then the module that
             * is represented by that string is fetched for the appropriate context.
             *
             * If the first argument is an array, then it will be treated as an array
             * of dependency string names to fetch. An optional function callback can
             * be specified to execute when all of those dependencies are available.
             *
             * Make a local req variable to help Caja compliance (it assumes things
             * on a require that are not standardized), and to give a short
             * name for minification/local scope use.
             */
            req = requirejs = function (deps, callback, errback, optional) {

                //Find the right context, use default
                var context, config,
                    contextName = defContextName;

                // Determine if have config object in the call.
                if (!isArray(deps) && typeof deps !== 'string') {
                    // deps is a config object
                    config = deps;
                    if (isArray(callback)) {
                        // Adjust args if there are dependencies
                        deps = callback;
                        callback = errback;
                        errback = optional;
                    } else {
                        deps = [];
                    }
                }

                if (config && config.context) {
                    contextName = config.context;
                }

                context = getOwn(contexts, contextName);
                if (!context) {
                    context = contexts[contextName] = req.s.newContext(contextName);
                }

                if (config) {
                    context.configure(config);
                }

                return context.require(deps, callback, errback);
            };

            /**
             * Support require.config() to make it easier to cooperate with other
             * AMD loaders on globally agreed names.
             */
            req.config = function (config) {
                return req(config);
            };

            /**
             * Execute something after the current tick
             * of the event loop. Override for other envs
             * that have a better solution than setTimeout.
             * @param  {Function} fn function to execute later.
             */
            req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
                setTimeout(fn, 4);
            } : function (fn) { fn(); };

            /**
             * Export require as a global, but only if it does not already exist.
             */
            if (!require) {
                require = req;
            }

            req.version = version;

            //Used to filter out dependencies that are already paths.
            req.jsExtRegExp = /^\/|:|\?|\.js$/;
            req.isBrowser = isBrowser;
            s = req.s = {
                contexts: contexts,
                newContext: newContext
            };

            //Create default context.
            req({});

            //Exports some context-sensitive methods on global require.
            each([
                'toUrl',
                'undef',
                'defined',
                'specified'
            ], function (prop) {
                //Reference from contexts instead of early binding to default context,
                //so that during builds, the latest instance of the default context
                //with its config gets used.
                req[prop] = function () {
                    var ctx = contexts[defContextName];
                    return ctx.require[prop].apply(ctx, arguments);
                };
            });

            if (isBrowser) {
                head = s.head = document.getElementsByTagName('head')[0];
                //If BASE tag is in play, using appendChild is a problem for IE6.
                //When that browser dies, this can be removed. Details in this jQuery bug:
                //http://dev.jquery.com/ticket/2709
                baseElement = document.getElementsByTagName('base')[0];
                if (baseElement) {
                    head = s.head = baseElement.parentNode;
                }
            }

            /**
             * Any errors that require explicitly generates will be passed to this
             * function. Intercept/override it if you want custom error handling.
             * @param {Error} err the error object.
             */
            req.onError = defaultOnError;

            /**
             * Creates the node for the load command. Only used in browser envs.
             */
            req.createNode = function (config, moduleName, url) {
                var node = config.xhtml ?
                        document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                        document.createElement('script');
                node.type = config.scriptType || 'text/javascript';
                node.charset = 'utf-8';
                node.async = true;
                return node;
            };

            /**
             * Does the request to load a module for the browser case.
             * Make this a separate function to allow other environments
             * to override it.
             *
             * @param {Object} context the require context to find state.
             * @param {String} moduleName the name of the module.
             * @param {Object} url the URL to the module.
             */
            req.load = function (context, moduleName, url) {
                var config = (context && context.config) || {},
                    node;
                if (isBrowser) {
                    //In the browser so use a script tag
                    node = req.createNode(config, moduleName, url);

                    node.setAttribute('data-requirecontext', context.contextName);
                    node.setAttribute('data-requiremodule', moduleName);

                    //Set up load listener. Test attachEvent first because IE9 has
                    //a subtle issue in its addEventListener and script onload firings
                    //that do not match the behavior of all other browsers with
                    //addEventListener support, which fire the onload event for a
                    //script right after the script execution. See:
                    //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
                    //UNFORTUNATELY Opera implements attachEvent but does not follow the script
                    //script execution mode.
                    if (node.attachEvent &&
                        //Check if node.attachEvent is artificially added by custom script or
                        //natively supported by browser
                        //read https://github.com/jrburke/requirejs/issues/187
                        //if we can NOT find [native code] then it must NOT natively supported.
                        //in IE8, node.attachEvent does not have toString()
                        //Note the test for "[native code" with no closing brace, see:
                        //https://github.com/jrburke/requirejs/issues/273
                            !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                            !isOpera) {
                        //Probably IE. IE (at least 6-8) do not fire
                        //script onload right after executing the script, so
                        //we cannot tie the anonymous define call to a name.
                        //However, IE reports the script as being in 'interactive'
                        //readyState at the time of the define call.
                        useInteractive = true;

                        node.attachEvent('onreadystatechange', context.onScriptLoad);
                        //It would be great to add an error handler here to catch
                        //404s in IE9+. However, onreadystatechange will fire before
                        //the error handler, so that does not help. If addEventListener
                        //is used, then IE will fire error before load, but we cannot
                        //use that pathway given the connect.microsoft.com issue
                        //mentioned above about not doing the 'script execute,
                        //then fire the script load event listener before execute
                        //next script' that other browsers do.
                        //Best hope: IE10 fixes the issues,
                        //and then destroys all installs of IE 6-9.
                        //node.attachEvent('onerror', context.onScriptError);
                    } else {
                        node.addEventListener('load', context.onScriptLoad, false);
                        node.addEventListener('error', context.onScriptError, false);
                    }
                    node.src = url;

                    //For some cache cases in IE 6-8, the script executes before the end
                    //of the appendChild execution, so to tie an anonymous define
                    //call to the module name (which is stored on the node), hold on
                    //to a reference to this node, but clear after the DOM insertion.
                    currentlyAddingScript = node;
                    if (baseElement) {
                        head.insertBefore(node, baseElement);
                    } else {
                        head.appendChild(node);
                    }
                    currentlyAddingScript = null;

                    return node;
                } else if (isWebWorker) {
                    try {
                        //In a web worker, use importScripts. This is not a very
                        //efficient use of importScripts, importScripts will block until
                        //its script is downloaded and evaluated. However, if web workers
                        //are in play, the expectation that a build has been done so that
                        //only one script needs to be loaded anyway. This may need to be
                        //reevaluated if other use cases become common.
                        importScripts(url);

                        //Account for anonymous modules
                        context.completeLoad(moduleName);
                    } catch (e) {
                        context.onError(makeError('importscripts',
                                        'importScripts failed for ' +
                                            moduleName + ' at ' + url,
                                        e,
                                        [moduleName]));
                    }
                }
            };

            function getInteractiveScript() {
                if (interactiveScript && interactiveScript.readyState === 'interactive') {
                    return interactiveScript;
                }

                eachReverse(scripts(), function (script) {
                    if (script.readyState === 'interactive') {
                        return (interactiveScript = script);
                    }
                });
                return interactiveScript;
            }

            //Look for a data-main script attribute, which could also adjust the baseUrl.
            if (isBrowser && !cfg.skipDataMain) {
                //Figure out baseUrl. Get it from the script tag with require.js in it.
                eachReverse(scripts(), function (script) {
                    //Set the 'head' where we can append children by
                    //using the script's parent.
                    if (!head) {
                        head = script.parentNode;
                    }

                    //Look for a data-main attribute to set main script for the page
                    //to load. If it is there, the path to data main becomes the
                    //baseUrl, if it is not already set.
                    dataMain = script.getAttribute('data-main');
                    if (dataMain) {
                        //Preserve dataMain in case it is a path (i.e. contains '?')
                        mainScript = dataMain;

                        //Set final baseUrl if there is not already an explicit one.
                        if (!cfg.baseUrl) {
                            //Pull off the directory of data-main for use as the
                            //baseUrl.
                            src = mainScript.split('/');
                            mainScript = src.pop();
                            subPath = src.length ? src.join('/') + '/' : './';

                            cfg.baseUrl = subPath;
                        }

                        //Strip off any trailing .js since mainScript is now
                        //like a module name.
                        mainScript = mainScript.replace(jsSuffixRegExp, '');

                        //If mainScript is still a path, fall back to dataMain
                        if (req.jsExtRegExp.test(mainScript)) {
                            mainScript = dataMain;
                        }

                        //Put the data-main script in the files to load.
                        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                        return true;
                    }
                });
            }

            /**
             * The function that handles definitions of modules. Differs from
             * require() in that a string for the module should be the first argument,
             * and the function to execute after dependencies are loaded should
             * return a value to define the module corresponding to the first argument's
             * name.
             */
            define = function (name, deps, callback) {
                var node, context;

                //Allow for anonymous modules
                if (typeof name !== 'string') {
                    //Adjust args appropriately
                    callback = deps;
                    deps = name;
                    name = null;
                }

                //This module may not have dependencies
                if (!isArray(deps)) {
                    callback = deps;
                    deps = null;
                }

                //If no name, and callback is a function, then figure out if it a
                //CommonJS thing with dependencies.
                if (!deps && isFunction(callback)) {
                    deps = [];
                    //Remove comments from the callback string,
                    //look for require calls, and pull them into the dependencies,
                    //but only if there are function args.
                    if (callback.length) {
                        callback
                            .toString()
                            .replace(commentRegExp, '')
                            .replace(cjsRequireRegExp, function (match, dep) {
                                deps.push(dep);
                            });

                        //May be a CommonJS thing even without require calls, but still
                        //could use exports, and module. Avoid doing exports and module
                        //work though if it just needs require.
                        //REQUIRES the function to expect the CommonJS variables in the
                        //order listed below.
                        deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
                    }
                }

                //If in IE 6-8 and hit an anonymous define() call, do the interactive
                //work.
                if (useInteractive) {
                    node = currentlyAddingScript || getInteractiveScript();
                    if (node) {
                        if (!name) {
                            name = node.getAttribute('data-requiremodule');
                        }
                        context = contexts[node.getAttribute('data-requirecontext')];
                    }
                }

                //Always save off evaluating the def call until the script onload handler.
                //This allows multiple modules to be in a file without prematurely
                //tracing dependencies, and allows for anonymous module support,
                //where the module name is not known until the script onload event
                //occurs. If no context, use the global queue, and get it processed
                //in the onscript load callback.
                (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
            };

            define.amd = {
                jQuery: true
            };


            /**
             * Executes the text. Normally just uses eval, but can be modified
             * to use a better, environment-specific call. Only used for transpiling
             * loader plugins, not for plain JS modules.
             * @param {String} text the text to execute/evaluate.
             */
            req.exec = function (text) {
                /*jslint evil: true */
                return eval(text);
            };

            //Set up with config info.
            req(cfg);
        }(this));
    </script>
    <script>
requirejs.config({
    "baseUrl": "js/lib",
    "paths": {
        "jquery": "https://cdnjs.cloudflare.com/ajax/libs/jquery/1.8.0/jquery-1.8.0.min",
        "lodash": "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.min",
        "highcharts": "https://cdnjs.cloudflare.com/ajax/libs/highcharts/3.0.10/highcharts",
        "lz": "https://storage.googleapis.com/versions.lumenize.com/v0.7.3/Lumenize-min"
    },
    "shim": {
        "lodash": {
            exports: "_"
        },
        "highcharts": {
            exports: "Highcharts"
        }
    }
});</script>
    <script>define('promise', [], function () { return Promise; });</script>
    <script>
define('lumenize', ['lz'], function () {
    return require("./lumenize")
});</script>
    <script>
(function () {
    var __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    define('easel-log', ['lodash'], function (_) {
        var Logger, debugf, errorf, infof, rootLog, warnf, _normalize;
        debugf = console.debug ? function (x, a) {
            return console.debug(x, a);
        } : function (x, a) {
            return console.log(x, a);
        };
        infof = console.info ? function (x, a) {
            return console.info(x, a);
        } : function (x, a) {
            return console.log(x, a);
        };
        warnf = console.warn ? function (x, a) {
            return console.warn(x, a);
        } : function (x, a) {
            return console.log(x, a);
        };
        errorf = console.error ? function (x, a) {
            return console.error(x, a);
        } : function (x, a) {
            return console.log(x, a);
        };
        _normalize = function (message, object) {
            if (_.isObject(message)) {
                object = message;
                message = object.message || 'no message';
            }
            return {
                object: object,
                message: message
            };
        };
        Logger = (function () {
            Logger.Levels = {
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3
            };

            Logger.level = Logger.Levels.INFO;

            function Logger(name) {
                this.currentLevel = __bind(this.currentLevel, this);
                this.prefix = name;
            }

            Logger.prototype.prefixedMessage = function (clazz, level, message) {
                return (clazz != null ? clazz : clazz + {
                    ':': ''
                }) + ':' + level + ':' + message;
            };

            Logger.prototype.setLevel = function (name) {
                if (typeof Logger.Levels[name] !== 'undefined') {
                    return Logger.level = Logger.Levels[name];
                } else {
                    return console.log(name, 'is an unknown logging level, use any of', Logger.Levels);
                }
            };

            Logger.prototype.currentLevel = function () {
                var key, value, _ref;
                _ref = Logger.Levels;
                for (key in _ref) {
                    value = _ref[key];
                    if (Logger.Levels[key] === Logger.level) {
                        return key;
                    }
                }
                return null;
            };

            Logger.prototype.createLog = function (prefix) {
                return new Logger(prefix);
            };

            Logger.prototype.error = function (message, object) {
                var n, _ref;
                n = _normalize(message, object);
                if (Logger.level <= Logger.Levels.ERROR) {
                    errorf(this.prefixedMessage(this.prefix, 'ERROR', n.message), n.object);
                    if (((_ref = n.object) != null ? _ref.stack : void 0) != null) {
                        return errorf(n.object.stack);
                    }
                }
            };

            Logger.prototype.warn = function (message, object) {
                var n;
                n = _normalize(message, object);
                if (Logger.level <= Logger.Levels.WARN) {
                    return warnf(this.prefixedMessage(this.prefix, 'WARN', n.message), n.object);
                }
            };

            Logger.prototype.info = function (message, object) {
                var n;
                n = _normalize(message, object);
                if (Logger.level <= Logger.Levels.INFO) {
                    return infof(this.prefixedMessage(this.prefix, 'INFO', n.message), n.object);
                }
            };

            Logger.prototype.debug = function (message, object) {
                var n;
                n = _normalize(message, object);
                if (Logger.level <= Logger.Levels.DEBUG) {
                    return debugf(this.prefixedMessage(this.prefix, 'DEBUG', n.message), n.object);
                }
            };

            return Logger;

        })();
        rootLog = new Logger('ROOT');
        return rootLog;
    });

}).call(this);
    </script>
    <script>
        /*
        Utility package that allows the coercion of values from
        one type to another
         */

        (function () {
            define("easel-converters", [], function () {
                var exports, toArray, toInt, toObjectLiteral;
                toInt = function (value, defaultIfNotInt) {
                    var returnValue;
                    if (!value) {
                        return defaultIfNotInt;
                    }
                    returnValue = parseInt(value);
                    if (!isNaN(returnValue)) {
                        return returnValue;
                    }
                    return defaultIfNotInt;
                };
                toArray = function (value) {
                    var k, result, v;
                    if (value === null || typeof value === 'undefined') {
                        return [];
                    }
                    if (typeof value === 'number') {
                        result = [value];
                    } else if (typeof value === 'boolean') {
                        result = [value];
                    } else if (typeof value === 'string') {
                        result = value.split(',');
                    } else if (Array.isArray(value)) {
                        result = value;
                    } else {
                        result = [];
                        for (k in value) {
                            v = value[k];
                            result.push(k);
                        }
                    }
                    return result;
                };
                toObjectLiteral = function (value) {
                    var k, obj, parsed, parsedItem, splitValue, splits, str, tmp, v, _i, _j, _len, _len1;
                    if (value === null || typeof value === 'undefined') {
                        return {};
                    }
                    if (typeof value === 'string') {
                        splits = value.split(',');
                        if (splits.length > 1) {
                            obj = {};
                            for (_i = 0, _len = splits.length; _i < _len; _i++) {
                                splitValue = splits[_i];
                                tmp = toObjectLiteral(splitValue);
                                for (k in tmp) {
                                    v = tmp[k];
                                    obj[k] = tmp[k];
                                }
                            }
                            return obj;
                        }
                    }
                    str = JSON.stringify(value);
                    if (!str) {
                        return {};
                    }
                    parsed = JSON.parse(str);
                    if (parsed === null) {
                        return {};
                    }
                    if (typeof parsed === 'string' || typeof parsed === 'number') {
                        obj = {};
                        obj[parsed] = 1;
                        return obj;
                    }
                    if (Array.isArray(parsed)) {
                        obj = {};
                        for (_j = 0, _len1 = parsed.length; _j < _len1; _j++) {
                            parsedItem = parsed[_j];
                            tmp = toObjectLiteral(parsedItem);
                            for (k in tmp) {
                                v = tmp[k];
                                obj[k] = tmp[k];
                            }
                        }
                        return obj;
                    }
                    return parsed;
                };
                return exports = {
                    toInt: toInt,
                    toArray: toArray,
                    toObjectLiteral: toObjectLiteral
                };
            });

        }).call(this);
    </script>
    <script>
        /*
        iff(value, valueIfDefined, valueIfNotDefined, callbackIfDef)
        if value evaluates to true, this will call 'callbackIfDef' (if supplied) and return valueIfDefined.
        if value is not truthy then this will return valueIfNotDefined.

        _ifdef = (value, valueIfDefined, valueIfNotDefined, callbackIfDef)
         */

        (function () {
            define("easel-util", [], function () {
                var exports, _appendPath, _ifdef, _iff;
                String.prototype.endsWith = String.prototype.endsWith || function (suffix) {
                    return this.indexOf(suffix, this.length - suffix.length) !== -1;
                };
                _iff = function (value, valueIfTruthy, valueIfNotTruthy, callbackIfTruthy) {
                    var returnValue;
                    returnValue = value ? valueIfTruthy : valueIfNotTruthy;
                    if (value && callbackIfTruthy) {
                        callbackIfTruthy();
                    }
                    return returnValue;
                };
                _ifdef = function (value, valueIfDefined, valueIfNotDefined, callbackIfDef) {
                    var isdefined, returnValue;
                    isdefined = typeof value !== 'undefined';
                    returnValue = isdefined ? valueIfDefined : valueIfNotDefined;
                    if (isdefined && callbackIfDef) {
                        callbackIfDef();
                    }
                    return returnValue;
                };
                _appendPath = function (to, value) {
                    if (to.endsWith('/')) {
                        return to + value;
                    } else {
                        return to + '/' + value;
                    }
                };
                return exports = {
                    iff: _iff,
                    ifdef: _ifdef,
                    appendPath: _appendPath
                };
            });

        }).call(this);
    </script>
    <script>
(function () {
    var __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
      __hasProp = {}.hasOwnProperty,
      __extends = function (child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

    define("easel-engine", ["easel-lbapi", "easel-wsapi", "easel-log", 'easel-promises', "easel-toolkit", "highcharts", "lumenize", "lodash"], function (lbapiFactory, wsapiFactory, log, promise, toolkit, highcharts, lumenize, _) {
        var Engine, EngineError, EngineWarning, SilentPipelineHalt, UnresolvedWarning, exports, expose;
        log = log.createLog("easel-engine");
        expose = function (what, on_, as) {
            if (Array.isArray(on_)) {
                on_.forEach(function (it) {
                    expose(what, it, as);
                });
                return;
            }
            log.debug("Exposing " + what + " on " + on_ + " as " + as);
            on_[as] = what;
        };
        SilentPipelineHalt = (function () {
            function SilentPipelineHalt() { }

            return SilentPipelineHalt;

        })();
        EngineError = (function () {
            function EngineError(args) {
                _.assign(this, args);
            }

            return EngineError;

        })();
        EngineWarning = (function () {
            function EngineWarning(options) {
                if (options == null) {
                    options = {};
                }
                this.halt = __bind(this.halt, this);
                if (options.type === void 0 || typeof options.type !== 'string') {
                    throw new Error("type is a required argument");
                }
                if (options.message === void 0 || typeof options.message !== 'string') {
                    throw new Error("message is a required argument");
                }
                _.assign(this, options);
                this._halt = false;
            }

            EngineWarning.prototype.halt = function (value) {
                if (value !== void 0) {
                    this._halt = !!value;
                }
                return this._halt;
            };

            return EngineWarning;

        })();
        UnresolvedWarning = (function (_super) {
            __extends(UnresolvedWarning, _super);

            function UnresolvedWarning() {
                this.use = __bind(this.use, this);
                return UnresolvedWarning.__super__.constructor.apply(this, arguments);
            }

            UnresolvedWarning.prototype.use = function (value) {
                if (value !== void 0) {
                    this._use = value;
                }
                return this._use;
            };

            return UnresolvedWarning;

        })(EngineWarning);
        Engine = (function () {
            Engine.Events = ['engine.error', 'engine.pipeline.start', 'engine.init.start', 'engine.init.warning', 'engine.init.error', 'engine.init.complete', 'engine.query.start', 'engine.query.warning', 'engine.query.error', 'engine.query.complete', 'engine.transform.start', 'engine.transform.warning', 'engine.transform.error', 'engine.transform.complete', 'engine.visualize.start', 'engine.visualize.warning', 'engine.visualize.error', 'engine.visualize.complete', 'engine.pipeline.complete'];

            function Engine(mychart) {
                this.reload = __bind(this.reload, this);
                this.launch = __bind(this.launch, this);
                this.prefs = __bind(this.prefs, this);
                this._warnAboutEmptyDataFromQuery = __bind(this._warnAboutEmptyDataFromQuery, this);
                this._emitPhaseError = __bind(this._emitPhaseError, this);
                this._emitPhaseErrorExplosively = __bind(this._emitPhaseErrorExplosively, this);
                this._emitEngineError = __bind(this._emitEngineError, this);
                this._showLoading = __bind(this._showLoading, this);
                this.init = __bind(this.init, this);
                this._unsafeRunVisualization = __bind(this._unsafeRunVisualization, this);
                this._unsafeRunTransform = __bind(this._unsafeRunTransform, this);
                this._unsafeRunQuery = __bind(this._unsafeRunQuery, this);
                this._unsafeRunInit = __bind(this._unsafeRunInit, this);
                this._substituteHangmanVariables = __bind(this._substituteHangmanVariables, this);
                this._hangmanVariables = __bind(this._hangmanVariables, this);
                this.destroy = __bind(this.destroy, this);
                this.on = __bind(this.on, this);
                this.emit = __bind(this.emit, this);
                var _emit, _runPhase;
                this.mychart = mychart;
                this._eventListeners = {};
                _emit = (function (_this) {
                    return function (phase, event) {
                        return function (data) {
                            var args;
                            args = ["engine." + phase + "." + event];
                            if (!_.isUndefined(data)) {
                                args.push(data);
                            }
                            _this.emit.apply(_this, args);
                            return data;
                        };
                    };
                })(this);
                this._emitQueryStart = _emit("query", "start");
                this._emitQueryComplete = _emit("query", "complete");
                this._emitPipelineStart = _emit("pipeline", "start");
                this._emitPipelineComplete = _emit("pipeline", "complete");
                this._emitVisualizeStart = _emit("visualize", "start");
                this._emitVisualizeComplete = _emit("visualize", "complete");
                this._emitTransformStart = _emit("transform", "start");
                this._emitQueryWarning = _emit("query", "warning");
                this._emitTransformWarning = _emit("transform", "warning");
                this._emitVisualizeWarning = _emit("visualize", "warning");
                this._emitTransformComplete = _emit("transform", "complete");
                this._emitVisualizeWarning = _emit("visualize", "warning");
                _runPhase = (function (_this) {
                    return function (phaseName, unsafe) {
                        return function (data) {
                            var errorHandler, ex, successHandler;
                            try {
                                successHandler = function () {
                                    return arguments[0];
                                };
                                errorHandler = function (err) {
                                    return _this._emitPhaseErrorExplosively(phaseName)(err);
                                };
                                return unsafe(data).then(successHandler, errorHandler);
                            } catch (_error) {
                                ex = _error;
                                log.error("Error during " + phaseName, ex);
                                if (ex instanceof SilentPipelineHalt) {
                                    _this._emitPhaseError(phaseName)("Execution has been halted.");
                                } else if (ex instanceof EngineError) {
                                    _this._emitEngineError(ex);
                                } else {
                                    _this._emitPhaseError(phaseName)(ex);
                                }
                                return promise.rejected(ex);
                            }
                        };
                    };
                })(this);
                this._runInit = _runPhase("init", this._unsafeRunInit);
                this._runQuery = _runPhase("query", this._unsafeRunQuery);
                this._runTransform = _runPhase("transform", this._unsafeRunTransform);
                this._runVisualization = _runPhase("visualize", this._unsafeRunVisualization);
            }

            Engine.prototype.emit = function (eventName) {
                var a, listeners;
                listeners = this._eventListeners[eventName] || [];
                log.debug("event emit:", eventName, "(", listeners.length.toString(), "listeners) => args:", arguments);
                a = Array.prototype.slice.call(arguments, 1);
                return listeners.forEach(function (cb) {
                    var e;
                    try {
                        return cb.apply(null, a);
                    } catch (_error) {
                        e = _error;
                        log.error("Error invoking callback for event", eventName, ":", [cb, e]);
                        throw e;
                    }
                });
            };

            Engine.prototype.on = function (eventName, callback) {
                var listeners;
                listeners = this._eventListeners[eventName] = this._eventListeners[eventName] || [];
                log.debug("registered listener on event:", eventName);
                listeners.push(callback);
            };

            Engine.prototype.destroy = function () {
                this._eventListeners.length = 0;
                delete this._eventListeners;
                return delete this.mychart;
            };

            Engine.prototype._hangmanVariables = function () {
                var env, hv;
                env = this.api().environment();
                hv = {};
                hv["__PROJECT_OID__"] = env["projectOid"];
                hv["__WORKSPACE_OID__"] = env["workspaceOid"];
                hv["__ITERATION_OID__"] = env["iterationOid"];
                hv["__ITERATION_START__"] = env["iterationStartDate"];
                hv["__ITERATION_END__"] = env["iterationEndDate"];
                hv["__RELEASE_OID__"] = env["releaseOid"];
                hv["__RELEASE_START__"] = env["releaseStartDate"];
                hv["__RELEASE_END__"] = env["releaseEndDate"];
                hv["__PROJECT_SCOPING_DOWN__"] = env["projectScopeDown"];
                hv["__PROJECT_OIDS_IN_SCOPE__"] = env["projectsInScopeOids"];
                hv["__PORTFOLIOITEM_OID__"] = env["portfolioItemOid"];
                hv["__PORTFOLIOITEM_START__"] = env["portfolioItemStartDate"];
                hv["__PORTFOLIOITEM_END__"] = env["portfolioItemEndDate"];
                log.debug("Returning hangman variables", hv);
                return hv;
            };

            Engine.prototype._substituteHangmanVariables = function (inThis, hv, emitWarningFn) {
                var inThisKey, inThisValue, resolvedValue, variableName, warning;
                hv = hv || this._hangmanVariables();
                for (inThisKey in inThis) {
                    inThisValue = inThis[inThisKey];
                    if (typeof inThisValue === "object") {
                        this._substituteHangmanVariables(inThisValue, hv, emitWarningFn);
                    } else if (typeof inThisValue === "string" && _.has(hv, inThisValue)) {
                        resolvedValue = hv[inThisValue];
                        inThis[inThisKey] = resolvedValue;
                        if (_.isUndefined(resolvedValue) || null === resolvedValue) {
                            warning = new UnresolvedWarning({
                                message: "Unable to resolve " + inThisValue + " for " + inThis,
                                type: 'unresolved',
                                variable: inThisValue
                            });
                            if (_.isFunction(emitWarningFn)) {
                                emitWarningFn(warning);
                            }
                            if (warning.halt() === true) {
                                throw new SilentPipelineHalt;
                            }
                            if (warning.use() !== void 0) {
                                inThis[inThisKey] = warning.use();
                            } else {
                                throw new Error("Unable to resolve " + inThisValue + " for " + inThisKey);
                            }
                        }
                    } else if (typeof inThisValue === 'string' && /#\{\s*(\w+)\s*\}/.test(inThisValue) === true) {
                        variableName = inThisValue.match(/#\{\s*(\w+)\s*\}/)[1];
                        warning = new UnresolvedWarning({
                            message: "Unable to resolve " + variableName + " for " + inThis,
                            type: 'unresolved',
                            variable: variableName
                        });
                        if (_.isFunction(emitWarningFn)) {
                            emitWarningFn(warning);
                        }
                        if (warning.halt() === true) {
                            throw new SilentPipelineHalt;
                        }
                        if (warning.use() !== void 0) {
                            inThis[inThisKey] = warning.use();
                        } else {
                            throw new Error("Unable to resolve " + variableName + " for " + inThisKey);
                        }
                    }
                }
                return inThis;
            };

            Engine.prototype._unsafeRunInit = function () {
                var deferred, el;
                deferred = promise.defer();
                el = this.api().el();
                if (_.isUndefined(el) || _.isNull(el)) {
                    deferred.reject("EL is not defined");
                }
                if (_.isFunction(this.mychart.init)) {
                    this.mychart.init();
                } else if (this.mychart.config && this.mychart.config.chart) {
                    this.mychart.config.chart.chart = this.mychart.config.chart.chart || {};
                    this.mychart.config.chart.chart.renderTo = this.api().el().id;
                    this.mychart.chart = new highcharts.Chart(this.mychart.config.chart);
                }
                deferred.resolve();
                return deferred.promise;
            };

            Engine.prototype._unsafeRunQuery = function () {
                var config, deferred, halt, p, returnValue, warning, _ref;
                if (this.mychart.query) {
                    this._emitQueryStart();
                    log.debug("calling .query() on chart");
                    deferred = promise.defer();
                    returnValue = this.mychart.query(deferred.resolve, deferred.reject);
                    if (returnValue !== void 0 && typeof returnValue["then"] === "function") {
                        p = returnValue;
                    } else if (returnValue !== void 0) {
                        log.warn("You should return a promise or you should call the done callback with the results");
                        p = promise.fulfilled(returnValue);
                    } else {
                        p = deferred.promise;
                    }
                    return p.then((function (_this) {
                        return function (data) {
                            _this._emitQueryComplete(data);
                            return data;
                        };
                    })(this));
                }
                if (((_ref = this.mychart.config) != null ? _ref.query : void 0) != null) {
                    log.debug("Running query based on declaration");
                    this._emitQueryStart();
                    config = _.cloneDeep(this.mychart.config.query);
                    log.debug("Preresolved query config", config);
                    config = this._substituteHangmanVariables(config, void 0, this._emitQueryWarning);
                    log.debug("Resolved query config", config);
                    p = this.lbapi().snapshots().find(config.find).hydrate(config.hydrate || []).fields(config.fields).sort(config.sort || {}).compress(config.compress || false).getAll();
                    p = p.then((function (_this) {
                        return function (data) {
                            _this._emitQueryComplete(data);
                            return data;
                        };
                    })(this));
                    return p;
                }
                this._emitQueryStart();
                warning = new EngineWarning({
                    type: 'notimplemented',
                    message: 'You have implemented neither a query method, nor declared a config.query section in your visualization.'
                });
                this._emitQueryWarning(warning);
                halt = warning.halt();
                if (halt) {
                    return promise.rejected(new SilentPipelineHalt());
                } else {
                    p = promise.resolved({
                        $stubbed: true,
                        Results: []
                    });
                    p = p.then((function (_this) {
                        return function (data) {
                            _this._emitQueryComplete(data);
                            return data;
                        };
                    })(this));
                    return p;
                }
            };

            Engine.prototype._unsafeRunTransform = function (data) {
                var calculator, calculatorType, config, deferred, errorFn, halt, key, p, rangeSpecJson, returnValue, startOnISOString, successFn, upToDateISOString, warning, _ref;
                if (this.mychart.transform) {
                    this._emitTransformStart();
                    deferred = promise.defer();
                    returnValue = this.mychart.transform(deferred.resolve, deferred.reject, data);
                    if (returnValue !== void 0 && typeof returnValue["then"] === "function") {
                        p = returnValue;
                    } else if (returnValue !== void 0) {
                        log.warn("You should return a promise or you should call the done callback with the results");
                        p = promise.resolved(returnValue);
                    } else {
                        p = deferred.promise;
                    }
                    return p.then((function (_this) {
                        return function (data) {
                            return _this._emitTransformComplete(data);
                        };
                    })(this));
                }
                if (((_ref = this.mychart.config) != null ? _ref.transform : void 0) !== void 0) {
                    this._emitTransformStart();
                    config = _.cloneDeep(this.mychart.config.transform) || {};
                    log.debug("Preresolved transform config", config);
                    config = this._substituteHangmanVariables(config, void 0, this._emitTransformWarning);
                    log.debug("Resolved transform config", config);
                    config["granularity"] = lumenize.Time[config["granularity"]] || lumenize.Time.DAY;
                    config["tz"] = config["tz"] || "America/Denver";
                    calculatorType = config.calculator || "timeseries";
                    calculatorType = calculatorType.toLowerCase();
                    rangeSpecJson = config.timeline || {};
                    for (key in rangeSpecJson) {
                        config[key] = rangeSpecJson[key];
                    }
                    if (!rangeSpecJson.startOn) {
                        rangeSpecJson.startOn = _.min(_.map(_.pluck(data.Results, '_ValidFrom'), function (d) {
                            return new Date(d);
                        }));
                    }
                    if (!rangeSpecJson.endBefore) {
                        rangeSpecJson.endBefore = _.max(_.map(_.pluck(data.Results, '_ValidFrom'), function (d) {
                            return new Date(d);
                        }));
                    }
                    if (calculatorType === "timeseries") {
                        calculator = new lumenize.TimeSeriesCalculator(config);
                    }
                    startOnISOString = new lumenize.Time(rangeSpecJson.startOn, "day", "Etc/UTC").getISOStringInTZ(config.tz);
                    upToDateISOString = new lumenize.Time(rangeSpecJson.endBefore, "day", "Etc/UTC").getISOStringInTZ(config.tz);
                    window.easelCalculator = calculator;
                    successFn = null;
                    errorFn = null;
                    deferred = promise.defer();
                    _.defer((function (_this) {
                        return function () {
                            var e, ss;
                            try {
                                calculator.addSnapshots(data.Results, startOnISOString, upToDateISOString);
                                ss = calculator.getResults().seriesData;
                                return deferred.resolve(ss);
                            } catch (_error) {
                                e = _error;
                                log.error("Error adding snapshots", e);
                                return deferred.reject(e);
                            }
                        };
                    })(this));
                    return deferred.promise.then((function (_this) {
                        return function (data) {
                            return _this._emitTransformComplete(data);
                        };
                    })(this));
                }
                this._emitTransformStart();
                warning = new EngineWarning({
                    type: 'notimplemented',
                    message: 'You have implemented neither a transform method, nor declared a config.transform section in your visualization.'
                });
                this._emitTransformWarning(warning);
                halt = warning.halt();
                if (halt) {
                    return promise.rejected(new SilentPipelineHalt());
                } else {
                    p = promise.resolved(data);
                    p = p.then((function (_this) {
                        return function (data) {
                            if (_.has(data, 'Results') && _.isArray(data.Results) && data.Results.length > 100) {
                                log.warn("Your query has returned " + data.Results.length + " results, and you have no transform defined.  The results have been limited to 100.");
                                data.Results = data.Results.splice(0, 100);
                            }
                            return _this._emitTransformComplete(data != null ? data.Results : void 0);
                        };
                    })(this));
                    return p;
                }
            };

            Engine.prototype._unsafeRunVisualization = function (data) {
                var deferred, halt, p, returnValue, tmp, warning, _ref;
                if (this.mychart.visualize) {
                    this._emitVisualizeStart();
                    log.debug("calling 'visualize'");
                    deferred = promise.defer();
                    returnValue = this.mychart.visualize(deferred.resolve, deferred.reject, data);
                    if (returnValue !== void 0 && typeof returnValue["then"] === "function") {
                        p = returnValue;
                    } else if (returnValue !== void 0) {
                        log.warn("You should return a promise or you should call the done callback with the results");
                        p = promise.resolved(returnValue);
                    } else {
                        p = deferred.promise;
                    }
                    return p.then((function (_this) {
                        return function (data) {
                            return _this._emitVisualizeComplete(data);
                        };
                    })(this));
                }
                if ((_ref = this.mychart.config) != null ? _ref.chart : void 0) {
                    this._emitVisualizeStart();
                    tmp = _.cloneDeep(this.mychart.config.chart) || {};
                    log.debug("Preresolved chart config", tmp);
                    tmp = this._substituteHangmanVariables(tmp, void 0, this._emitVisualizeWarning);
                    log.debug("Resolved chart config", tmp);
                    tmp.chart = tmp.chart || {};
                    tmp.chart.renderTo = this.api().el().id;
                    tmp.credits = tmp.credits || {
                        enabled: false
                    };
                    log.debug("creating highchart instance with", tmp);
                    deferred = promise.defer();
                    _.defer((function (_this) {
                        return function () {
                            var e;
                            try {
                                new toolkit.DefaultTimeSeriesRenderer(tmp).render(data);
                                _this.mychart.chart = new highcharts.Chart(tmp);
                                return deferred.resolve();
                            } catch (_error) {
                                e = _error;
                                log.error(e);
                                return deferred.reject(e);
                            }
                        };
                    })(this));
                    return deferred.promise.then((function (_this) {
                        return function () {
                            return _this._emitVisualizeComplete();
                        };
                    })(this));
                }
                this._emitVisualizeStart();
                warning = new EngineWarning({
                    type: 'notimplemented',
                    message: 'You have implemented neither a visualize method, nor declared a config.chart section in your visualization.'
                });
                this._emitVisualizeWarning(warning);
                halt = warning.halt();
                if (halt) {
                    return promise.rejected(new SilentPipelineHalt());
                }
                tmp = {
                    chart: {
                        renderTo: this.api().el().id
                    }
                };
                deferred = promise.defer();
                _.defer((function (_this) {
                    return function () {
                        var e;
                        try {
                            new toolkit.DefaultTimeSeriesRenderer(tmp).render(data);
                            _this.mychart.chart = new highcharts.Chart(tmp);
                            return deferred.resolve();
                        } catch (_error) {
                            e = _error;
                            log.error(e);
                            return deferred.reject(e);
                        }
                    };
                })(this));
                return deferred.promise.then((function (_this) {
                    return function () {
                        _this._emitVisualizeComplete();
                        return promise.resolved().then(function () {
                            return _this._emitVisualizeComplete();
                        });
                    };
                })(this));
            };


            /*
                   * @sychronous
             */

            Engine.prototype.init = function (shimApi) {
                var apiFunction, e, lbapi, wsapi;
                apiFunction = function () {
                    throw new Error("init was not called with an api instance");
                };
                if (shimApi) {
                    apiFunction = function () {
                        return shimApi;
                    };
                }
                expose(apiFunction, [this, this.mychart], "api");
                this.api();
                lbapi = function () {
                    return lbapiFactory(this.api().lbapiUrl());
                };
                expose(lbapi, [this, this.mychart, shimApi], "lbapi");
                wsapi = function () {
                    return wsapiFactory(this.api().wsapiUrl());
                };
                expose(wsapi, [this, this.mychart, shimApi], "wsapi");
                expose(this.on, shimApi, "on");
                try {
                    if (_.isFunction(shimApi.registerPreferences)) {
                        return shimApi.registerPreferences(this.prefs());
                    }
                } catch (_error) {
                    e = _error;
                    log.warn("An error occurred getting preferences.");
                    this._emitEngineError(e);
                    throw e;
                }
            };

            Engine.prototype._showLoading = function (message) {
                if (this.mychart.chart) {
                    if (_.isObject(message)) {
                        if (_.has(message, "responseText")) {
                            message = message.responseText;
                        } else {
                            message = JSON.stringify(message, null, 2);
                        }
                    }
                    return this.mychart.chart.showLoading(message);
                }
            };

            Engine.prototype._emitEngineError = function (error) {
                log.error(error);
                this.emit("engine.error", error);
                return this._showLoading(error);
            };


            /*
                   * Returns a function that accepts an error, emits the error
                   * then rethrows the error.  This is useful for
                   * promises, where you have to pass in functions.  Specifically,
                   * for the 'catch' portion of a promise where you need the
                   * catch function to rethrow the error so that it stays in the
                   * rejected pipeline and not the fulfulled pipeline
             */

            Engine.prototype._emitPhaseErrorExplosively = function (phase) {
                return (function (_this) {
                    return function (err) {
                        _this._emitPhaseError(phase)(err);
                        throw err;
                    };
                })(this);
            };


            /*
                   * Emits an error event if the event hasn't already been emitted.
             */

            Engine.prototype._emitPhaseError = function (phase) {
                return (function (_this) {
                    return function (error) {
                        if (error !== void 0 && !error.$$emitted) {
                            log.error(error);
                            error.$$emitted = true;
                            return _this.emit("engine." + phase + ".error", error);
                        }
                    };
                })(this);
            };

            Engine.prototype._warnAboutEmptyDataFromQuery = function (data) {
                var warning;
                if (!(data != null ? data.$stubbed : void 0) && ((data == null) || (data.Results == null) || data.Results.length === 0)) {
                    data = {
                        Results: []
                    };
                    warning = new EngineWarning({
                        type: 'nodata',
                        message: 'Your query returned no results.'
                    });
                    this._emitQueryWarning(warning);
                    log.warn("no data was returned from your query");
                    if (warning.halt()) {
                        throw new SilentPipelineHalt;
                    }
                }
                return data;
            };

            Engine.prototype.prefs = function () {
                var p, _base;
                if (_.has(this.mychart, 'prefs') && _.isFunction(this.mychart.prefs)) {
                    p = typeof (_base = this.mychart).prefs === "function" ? _base.prefs() : void 0;
                }
                return p = _.isArray(p) ? p : [];
            };

            Engine.prototype.launch = function () {
                var deferred, workspace;
                deferred = promise.defer();
                workspace = this.api().getWorkspace();
                if (workspace === undefined || (workspace == null) || workspace <= 0) {
                    this._emitEngineError("You do not have a workspace selected.");
                    log.debug("easel-engine::launch, workspace is not set, aborting");
                    deferred.reject("You do not have a workspace selected.");
                } else {
                    deferred.resolve();
                }
                return deferred.promise.then(this._emitPipelineStart).then(this._runInit, this._emitPhaseErrorExplosively("init")).then(this._runQuery, this._emitPhaseErrorExplosively("query")).then(this._warnAboutEmptyDataFromQuery).then(this._runTransform, this._emitPhaseErrorExplosively("transform")).then(this._runVisualization, this._emitPhaseErrorExplosively("visualize")).then(this._emitPipelineComplete);
            };

            Engine.prototype.reload = function () {
                var e;
                if (this.mychart.devisualize) {
                    try {
                        this.mychart.devisualize();
                    } catch (_error) {
                        e = _error;
                        log.error("Error devisualizing chart", e);
                        this._emitEngineError(e);
                    }
                } else {
                    if (this.mychart.chart && this.mychart.chart.series) {
                        while (this.mychart.chart.series.length > 0) {
                            this.mychart.chart.series[0].remove();
                        }
                    }
                }
                return this.launch();
            };

            return Engine;

        })();

        /*
            I think we need ot make this so that we pass the chart in. If we do that, then the loading
            of the chart can be odne in a number of different ways.
         */
        return exports = {
            SilentPipelineHalt: SilentPipelineHalt,
            EngineError: EngineError,
            EngineWarning: EngineWarning,
            UnresolvedWarning: UnresolvedWarning,
            Engine: Engine
        };
    });

}).call(this);
    </script>
    <script>
(function () {
    define("easel-toolkit", ['easel-log'], function (log) {
        var Colors, DefaultTimeSeriesRenderer, Defaults, TickIntervalCalculator, ToolkitError, exports;
        Defaults = (function () {
            function Defaults() { }

            Defaults.DEFAULT_TICK_INTERVAL_CHART_WIDTH = 640;

            Defaults.DEFAULT_TICK_INTERVAL_FONT_WIDTH = 10;

            Defaults.DEFAULT_LABEL_FIELD_NAME = 'label';

            Defaults.DEFAULT_LABEL_SECOND_CHOICE = '_ValidFrom';

            Defaults.DEFAULT_RENDER_ELEMENT_ID = 'mrcontainer';

            Defaults.DEFAULT_RENDERER_IGNORE_FIELDS = ['tick', 'ObjectID'];

            return Defaults;

        })();
        ToolkitError = (function () {
            function ToolkitError(args) {
                _.assign(this, args);
            }

            return ToolkitError;

        })();
        TickIntervalCalculator = (function () {
            function TickIntervalCalculator(options, labelFieldName) {
                var _ref;
                this.fieldName = labelFieldName || Defaults.DEFAULT_LABEL_FIELD_NAME;
                this.chartOptions = options || {};
                this.element = (_ref = this.chartOptions.chart) != null ? _ref.renderTo : void 0;
                if (!this.element) {
                    log.warn('chart.renderTo is not set, defaulting to "mrcontainer"');
                    this.element = 'mrcontainer';
                }
            }

            TickIntervalCalculator.prototype.apply = function (data) {
                var element, interval, label, labels, maxLabelWidth, maxWidth, width;
                element = document.getElementById(this.element);
                if (element === null) {
                    log.warn("Unable to locate the " + this.element);
                    return;
                }
                labels = _.pluck(data, this.fieldName);
                labels = _.map(labels, function (label, idx) {
                    return (label != null ? label.toString() : void 0) || idx.toString();
                });
                maxWidth = _.max((function () {
                    var _i, _len, _results;
                    _results = [];
                    for (_i = 0, _len = labels.length; _i < _len; _i++) {
                        label = labels[_i];
                        _results.push(label.length);
                    }
                    return _results;
                })());
                maxLabelWidth = Defaults.DEFAULT_TICK_INTERVAL_FONT_WIDTH * maxWidth;
                width = element.offsetWidth || 0;
                if (width === 0) {
                    width = Defaults.DEFAULT_TICK_INTERVAL_CHART_WIDTH;
                }
                this.chartOptions.xAxis = this.chartOptions.xAxis || {};
                interval = Math.ceil(labels.length / (width / maxLabelWidth));
                if (interval > 0) {
                    return this.chartOptions.xAxis.tickInterval = interval;
                }
            };

            return TickIntervalCalculator;

        })();
        DefaultTimeSeriesRenderer = (function () {
            function DefaultTimeSeriesRenderer(options) {
                var element, _ref;
                if (options == null) {
                    options = {};
                }
                this.options = options;
                this.categoryFieldName = Defaults.DEFAULT_LABEL_FIELD_NAME;
                element = (_ref = this.options.chart) != null ? _ref.renderTo : void 0;
                if (!element) {
                    log.warn("chart.renderTo is not set, defaulting to " + Defaults.DEFAULT_RENDER_ELEMENT_ID);
                    element = Defaults.DEFAULT_RENDER_ELEMENT_ID;
                }
            }

            DefaultTimeSeriesRenderer.prototype.render = function (data) {
                var allSeries, col, columnName, columns, i, isNumeric;
                this.options.xAxis = this.options.xAxis || {};
                this.options.xAxis.categories = this.options.xAxis.categories || _.pluck(data, this.categoryFieldName);
                this.options.series = this.options.series || [];
                if (data === null || data === void 0) {
                    data = [];
                }
                if (data.length > 0 && !_.has(data[0], this.categoryFieldName)) {
                    if (_.has(data[0], Defaults.DEFAULT_LABEL_SECOND_CHOICE)) {
                        this.categoryFieldName = Defaults.DEFAULT_LABEL_SECOND_CHOICE;
                    }
                }

                /*
                            expect the series to be configured in the chart config
                            with 'data' as the Field Name

                            given:
                            | a		| b		|
                            =================
                            | 123	| 456	|
                            | 123b	| 456b	|


                            series : [
                                { data:'a' },
                                { data:'b' }
                            ]

                            the two series would be the plucked values of a and b or [ [123,123b], [456,456b] ]
                 */
                if (this.options.series.length === 0) {
                    isNumeric = function (col) {
                        return _.filter(_.pluck(data, col), _.isNumber).length > 0;
                    };
                    columns = _.unique(_.flatten(_.map(data, _.keys)));
                    columns = (function () {
                        var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = columns.length; _i < _len; _i++) {
                            col = columns[_i];
                            if (col !== this.categoryFieldName && !_.contains(Defaults.DEFAULT_RENDERER_IGNORE_FIELDS, col) && isNumeric(col)) {
                                _results.push(col);
                            }
                        }
                        return _results;
                    }).call(this);
                    this.options.series = (function () {
                        var _i, _len, _results;
                        _results = [];
                        for (i = _i = 0, _len = columns.length; _i < _len; i = ++_i) {
                            columnName = columns[i];
                            _results.push({
                                name: columnName,
                                data: columnName
                            });
                        }
                        return _results;
                    })();
                }
                allSeries = this.options.series;
                _.each(allSeries, function (series) {
                    var field, sd;
                    field = series["data"];
                    if (field === void 0 || field === null) {
                        field = series["name"];
                    }
                    if (_.isString(field)) {
                        sd = _.pluck(data, field);
                        series["data"] = sd;
                    } else if (_.isFunction(field)) {
                        sd = _.map(data, field);
                        series["data"] = sd;
                    }
                });
                if (this.options.xAxis && !this.options.xAxis.tickInterval) {
                    return new TickIntervalCalculator(this.options, this.categoryFieldName).apply(data);
                }
            };

            return DefaultTimeSeriesRenderer;

        })();
        Colors = (function () {
            var colors, darken, expandColors, expanded, hexRgb, k, lighten, name, titleCase, v;

            function Colors() { }

            Colors.lightBlue = '#BDD7EA';

            Colors.LIGHT_BLUE = Colors.lightBlue;

            Colors.blue = '#7CAFD7';

            Colors.BLUE = Colors.blue;

            Colors.darkBlue = '#005EB8';

            Colors.DARK_BLUE = Colors.darkBlue;

            Colors.lightGreen = '#CADDA3';

            Colors.LIGHT_GREEN = Colors.lightGreen;

            Colors.green = '#8DC63F';

            Colors.GREEN = Colors.green;

            Colors.darkGreen = '#1E7C00';

            Colors.DARK_GREEN = Colors.darkGreen;

            Colors.lightYellow = '#FFDD82';

            Colors.LIGHT_YELLOW = Colors.lightYellow;

            Colors.yellow = '#FAD200';

            Colors.YELLOW = Colors.yellow;

            Colors.darkYellow = '#F6A900';

            Colors.DARK_YELLOW = Colors.darkYellow;

            Colors.lightRed = '#F2D3D0';

            Colors.LIGHT_RED = Colors.lightRed;

            Colors.darkGrey = '#666';

            Colors.DARK_GREY = Colors.darkGrey;

            Colors.lightGrey = '#E6E6E6';

            Colors.LIGHT_GREY = Colors.lightGrey;

            Colors.logoRed = '#logo_red';

            titleCase = function (s) {
                return "" + (s.toUpperCase().substring(0, 1)) + (s.substring(1));
            };

            darken = function (color, percent) {
                return lighten(color, -1 * percent);
            };

            lighten = function (color, percent) {
                var B, G, R, amt, num;
                num = parseInt(color.slice(1), 16);
                amt = Math.round(2.55 * percent);
                R = (num >> 16) + amt;
                G = (num >> 8 & 0x00FF) + amt;
                B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 + (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 + (B < 255 ? (B < 1 ? 0 : B) : 255)).toString(16).slice(1);
            };

            expandColors = function (colorName, baseColor) {
                var all;
                all = {};
                all["" + colorName] = baseColor;
                all["" + (colorName.toUpperCase())] = baseColor;
                all["light" + (titleCase(colorName))] = lighten(baseColor, 20);
                all["dark" + (titleCase(colorName))] = darken(baseColor, 20);
                all["LIGHT_" + (colorName.toUpperCase())] = lighten(baseColor, 20);
                all["DARK_" + (colorName.toUpperCase())] = darken(baseColor, 20);
                return all;
            };

            colors = {
                grey: "#C0C0C0",
                orange: "#FF8200",
                red: "#F66349",
                purple: "#7832A5"
            };

            for (k in colors) {
                v = colors[k];
                expanded = expandColors(k, v);
                for (name in expanded) {
                    hexRgb = expanded[name];
                    if (Colors[name] === void 0) {
                        Colors[name] = hexRgb;
                    }
                }
            }

            return Colors;

        })();
        return exports = {
            DefaultTimeSeriesRenderer: DefaultTimeSeriesRenderer,
            TickIntervalCalculator: TickIntervalCalculator,
            Defaults: Defaults,
            Colors: Colors
        };
    });

}).call(this);
    </script>
    <script>
        /*
        load 'promise.js'
         */

        (function () {
            define('easel-promises', ['promise'], function (PromiseJsPromise) {
                var Deferred, defer, exports, rejected, resolved;
                if (Promise === void 0) {
                    throw new Error("Promise is undefined, be sure to load a Promise library");
                }
                Deferred = (function () {
                    function Deferred() {
                        this.resolve = null;
                        this.reject = null;
                        this.promise = new PromiseJsPromise((function (_this) {
                            return function (fulfill, reject) {
                                _this.resolve = fulfill;
                                return _this.reject = reject;
                            };
                        })(this));
                    }

                    return Deferred;

                })();
                defer = function () {
                    return new Deferred();
                };
                resolved = function (value) {
                    return new PromiseJsPromise(function (fulfill, reject) {
                        return fulfill(value);
                    });
                };
                rejected = function (reason) {
                    return new PromiseJsPromise(function (fulfill, reject) {
                        return reject(reason);
                    });
                };
                return exports = {
                    defer: defer,
                    resolved: resolved,
                    fulfilled: resolved,
                    rejected: rejected,
                    Deferred: Deferred,
                    Promise: Promise
                };
            });

        }).call(this);
    </script>
    <script>
(function () {
    define('easel-http', ['jquery', 'easel-log', 'easel-promises'], function ($, log, promises) {
        var exports;
        return exports = {
            get: function (settings) {
                settings.type = 'GET';
                settings.data = settings.params;
                log.info('GETting', settings);
                return new promises.Promise(function (success, failure) {
                    var e;
                    try {
                        return $.ajax(settings).then(function (data) {
                            return success(data);
                        }, function (args) {
                            throw failure(args);
                        });
                    } catch (_error) {
                        e = _error;
                        return failure(e);
                    }
                });
            },
            post: function (settings) {
                settings.type = 'POST';
                log.info('POSTing', settings);
                return new promises.Promise(function (success, failure) {
                    var e;
                    try {
                        return $.ajax(settings).then(function (data) {
                            return success(data);
                        }, function (args) {
                            throw failure(args);
                        });
                    } catch (_error) {
                        e = _error;
                        return failure(e);
                    }
                });
            }
        };
    });

}).call(this);
    </script>
    <script>
(function () {
    var __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    define("easel-lbapi", ["easel-http", "easel-log", "easel-util", "easel-converters", "lodash"], function (http, log, util, converter, _) {
        var LBAPI, Snapshots;
        Snapshots = (function () {
            function Snapshots(lbapi) {
                this.getAll = __bind(this.getAll, this);
                this.nextPage = __bind(this.nextPage, this);
                this.get = __bind(this.get, this);
                this.find = __bind(this.find, this);
                this.pageSize = __bind(this.pageSize, this);
                this.removeUnauthorizedSnapshots = __bind(this.removeUnauthorizedSnapshots, this);
                this.compress = __bind(this.compress, this);
                this.sort = __bind(this.sort, this);
                this.start = __bind(this.start, this);
                this.andHydration = __bind(this.andHydration, this);
                this.withHydration = __bind(this.withHydration, this);
                this.hydrate = __bind(this.hydrate, this);
                this.andField = __bind(this.andField, this);
                this.withField = __bind(this.withField, this);
                this.fields = __bind(this.fields, this);
                this.buildPostQuery = __bind(this.buildPostQuery, this);
                this.lbapi = lbapi;
                this._fields = this.defaultFields();
                this._find = null;
                this._hydrate = [];
                this._lbapi = null;
                this._pagesize = 20000;
                this._start = 0;
                this._sort = {};
                this._compress = false;
                this._removeUnauthzSnapshots = false;
                this._results = [];
            }

            Snapshots.prototype.defaultFields = function () {
                return {
                    ObjectID: 1,
                    FormattedID: 1,
                    _ValidFrom: 1,
                    _ValidTo: 1
                };
            };

            Snapshots.prototype.buildPostQuery = function () {
                var i, query;
                if (this._find === null) {
                    log.error("find parameter is null.");
                    throw new Error("Cannot execute Lookback API query with empty find command");
                }
                i = 0;
                while (i < this._hydrate.length) {
                    if (!this._fields[this._hydrate[i]]) {
                        this._fields[this._hydrate[i]] = 1;
                    }
                    i++;
                }
                query = {};
                query.find = this._find;
                query.hydrate = this._hydrate;
                query.fields = this._fields;
                if (!_.isEmpty(this._sort)) {
                    query.sort = this._sort;
                }
                query.pagesize = this._pagesize;
                query.start = this._start;
                if (this._compress) {
                    query.compress = this._compress;
                }
                if (this._removeUnauthzSnapshots) {
                    query.removeUnauthorizedSnapshots = this._removeUnauthzSnapshots;
                }
                return query;
            };

            Snapshots.prototype.fields = function (fieldsParams) {
                var count, k;
                if (typeof fieldsParams === "undefined") {
                    return this._fields;
                }
                if (fieldsParams === true || fieldsParams === "true") {
                    this._fields = "true";
                    return this;
                }
                this._fields = converter.toObjectLiteral(fieldsParams);
                count = 0;
                for (k in this._fields) {
                    count++;
                }
                if (count === 0) {
                    this._fields = this.defaultFields();
                }
                return this;
            };

            Snapshots.prototype.withField = function (field) {
                var k, newField, _results;
                if (typeof field === "undefined") {
                    return this._fields;
                }
                if (field === true || field === "true" || this._fields === "true") {
                    this._fields = "true";
                    return this;
                }
                newField = converter.toObjectLiteral(field);
                _results = [];
                for (k in newField) {
                    _results.push(this._fields[k] = newField[k]);
                }
                return _results;
            };

            Snapshots.prototype.andField = function (field) {
                return this.withField(field);
            };

            Snapshots.prototype.hydrate = function (hydrateParams) {
                if (typeof hydrateParams === "undefined") {
                    return this._hydrate;
                }
                this._hydrate = converter.toArray(hydrateParams);
                return this;
            };

            Snapshots.prototype.withHydration = function (hydrateParams) {
                if (typeof hydrateParams === "undefined") {
                    return this._hydrate;
                }
                this._hydrate = this._hydrate.concat(converter.toArray(hydrateParams));
                return this;
            };

            Snapshots.prototype.andHydration = function (hydrateParams) {
                return this.withHydration(hydrateParams);
            };

            Snapshots.prototype.start = function (start) {
                return util.ifdef(start, this, this._start, (function (_this) {
                    return function () {
                        return _this._start = converter.toInt(start, _this._start);
                    };
                })(this));
            };

            Snapshots.prototype.sort = function (sortOn) {
                return util.ifdef(sortOn, this, this._sort, (function (_this) {
                    return function () {
                        return _.merge(_this._sort, sortOn);
                    };
                })(this));
            };

            Snapshots.prototype.compress = function (compress) {
                return util.ifdef(compress, this, this._compress, (function (_this) {
                    return function () {
                        if (compress === true || compress === 'true') {
                            return _this._compress = true;
                        }
                    };
                })(this));
            };

            Snapshots.prototype.removeUnauthorizedSnapshots = function (removeUnauthzSnapshots) {
                return util.ifdef(removeUnauthzSnapshots, this, this._removeUnauthzSnapshots, (function (_this) {
                    return function () {
                        if (removeUnauthzSnapshots === true || removeUnauthzSnapshots === 'true') {
                            return _this._removeUnauthzSnapshots = true;
                        }
                    };
                })(this));
            };

            Snapshots.prototype.pageSize = function (pageSize) {
                return util.ifdef(pageSize, this, this._pagesize, (function (_this) {
                    return function () {
                        return _this._pagesize = converter.toInt(pageSize, _this._pagesize);
                    };
                })(this));
            };

            Snapshots.prototype.find = function (find) {
                if (typeof find === "undefined") {
                    return this._find;
                }
                if (find === null) {
                    this._find = null;
                } else if (typeof find !== "object") {
                    log.error("Invalid find value type.", typeof find);
                    this._find = null;
                } else {
                    this._find = find;
                }
                return this;
            };

            Snapshots.prototype.get = function () {
                var data, query;
                query = this.buildPostQuery();
                data = JSON.stringify(query);
                return http.post({
                    url: this.lbapi.baseUrl,
                    data: data,
                    contentType: "application/json",
                    dataType: "json"
                });
            };

            Snapshots.prototype.nextPage = function () {
                this._start += this._pagesize;
                return this;
            };

            Snapshots.prototype.getAll = function () {
                var self;
                self = this;
                return this.get().then((function (_this) {
                    return function (data) {
                        _this._results = _this._results.concat(data.Results);
                        _this._pagesize = data.PageSize || _this._pagesize;
                        if (_this._start + _this._pagesize >= data.TotalResultCount) {
                            return {
                                TotalResultCount: _this._results.length,
                                Results: _this._results
                            };
                        } else {
                            return self.nextPage().getAll();
                        }
                    };
                })(this));
            };

            Snapshots;

            return Snapshots;

        })();
        LBAPI = (function () {
            function LBAPI(baseUrl) {
                this.baseUrl = baseUrl;
            }

            LBAPI.prototype.snapshots = function () {
                return new Snapshots(this);
            };

            return LBAPI;

        })();
        return function (baseUrl) {
            return new LBAPI(baseUrl);
        };
    });

}).call(this);
    </script>
    <script>
(function () {
    define("easel-wsapi", ["easel-http", "easel-log", "easel-util", "easel-converters"], function (http, log, util, converter) {
        var QueryBuilder, WSAPI;
        log = log.createLog("easel-wsapi");
        QueryBuilder = function (wsapi, type) {
            var buildGetQuery, _fields, _find, _objectType, _otherParams, _pagesize, _results, _start, _wsapi;
            _find = null;
            _fields = [];
            _wsapi = wsapi;
            _pagesize = 200;
            _start = 1;
            _results = [];
            _otherParams = {};
            _objectType = type;
            this.start = (function (_this) {
                return function (idx) {
                    return util.ifdef(idx, _this, _start, function () {
                        _start = converter.toInt(idx, _start);
                    });
                };
            })(this);
            this.pageSize = function (p) {
                return util.ifdef(p, this, _pagesize, function () {
                    _pagesize = converter.toInt(p, _pagesize);
                });
            };
            this.params = function (params) {
                if (typeof params === "undefined") {
                    return _otherParams;
                }
                if (typeof params === "object" && !Array.isArray(params)) {
                    _otherParams = params || {};
                } else {
                    _otherParams = {};
                    log.warn("Invalid parameter type.", params);
                }
                return this;
            };
            this.withParam = function (name, value) {
                return util.ifdef(name, this, _otherParams, function () {
                    if (typeof name === "string") {
                        _otherParams[name] = value;
                    } else {
                        log.warn("Invalid parameter key type.", typeof name);
                    }
                });
            };
            this.andParam = function (name, value) {
                return this.withParam(name, value);
            };
            this.order = function (value) {
                return this;
            };
            this.find = function (value) {
                if (value && typeof value === "string") {
                    _find = value;
                    return this;
                } else if (value) {
                    log.warn("Invalid find value type.", typeof value);
                    _find = null;
                    return this;
                } else {
                    return _find;
                }
            };
            buildGetQuery = function () {
                var key, query;
                query = {};
                query.find = _find;
                query.fetch = (typeof _fields === "boolean" ? _fields : _fields.join(","));
                query.pagesize = _pagesize;
                query.start = _start;
                for (key in _otherParams) {
                    query[key] = _otherParams[key];
                }
                return query;
            };
            this.fields = function (fieldsParams) {
                if (fieldsParams || typeof fieldsParams !== "undefined") {
                    _fields = converter.toArray(fieldsParams);
                    return this;
                }
                return _fields;
            };
            this.withFields = function (fieldsParams) {
                if (fieldsParams || typeof fieldsParams !== "undefined") {
                    _fields = _fields.concat(converter.toArray(fieldsParams));
                    return this;
                }
                return _fields;
            };
            this.andFields = this.withFields;
            this.fetchFullObject = function () {
                _fields = true;
                return this;
            };
            this.getOne = function () {
                _start = 1;
                _pagesize = 1;
                return this.get().then(function (data) {
                    if (data.QueryResult.Results && data.QueryResult.Results.length > 0) {
                        return data.QueryResult.Results[0];
                    }
                    return null;
                });
            };
            this.get = function () {
                var params;
                params = buildGetQuery();
                return http.get({
                    url: _wsapi.baseUrl + "/" + _objectType,
                    params: params,
                    dataType: "json"
                });
            };
            this.nextPage = function () {
                _start += _pagesize;
                return this;
            };
            this.getAll = function () {
                var self;
                self = this;
                return this.get().then(function (data) {
                    _results = _results.concat(data.QueryResult.Results);
                    if (_results.length >= data.QueryResult.TotalResultCount) {
                        return {
                            QueryResult: {
                                TotalResultCount: _results.length,
                                Results: _results
                            }
                        };
                    } else {
                        return self.nextPage().getAll();
                    }
                });
            };
            return this;
        };
        WSAPI = function (baseUrl) {
            var all, self, wsapiBase, _fixRef;
            this.baseUrl = baseUrl;
            wsapiBase = "/slm/webservice/v2.x";
            self = this;
            _fixRef = function (ref) {
                var u;
                u = ref.substring(ref.indexOf(wsapiBase) + wsapiBase.length + 1);
                return util.appendPath(baseUrl, u);
            };
            self.getByRef = function (resourceUrl, options) {
                return http.get({
                    url: _fixRef(resourceUrl),
                    dataType: "json",
                    params: options
                });
            };
            self.getMyWorkspaces = function () {
                return this.workspaces().start(1).pageSize(200).order("Name ASC,ObjectID").find("(State = \"Open\")").fields(["Name", "ObjectID"]).withParam("includePermissions", true).andParam("workspace", "null").fetchFullObject().getAll().then(function (d) {
                    return d.QueryResult.Results;
                });
            };
            self.getDateFormat = function () {
                return this.workspaceconfigurations().fetchFullObject().getOne().then(function (workspaceConfiguration) {
                    return workspaceConfiguration.DateFormat;
                });
            };
            self.getDateTimeFormat = function () {
                return this.workspaceconfigurations().fetchFullObject().getOne().then(function (workspaceConfiguration) {
                    return workspaceConfiguration.DateTimeFormat;
                });
            };
            self.me = function () {
                self = this;
                return http.get({
                    url: this.baseUrl + "/User",
                    dataType: "json"
                });
            };
            self.getDefaultProject = function () {
                self = this;
                return this.me().then(function (data) {
                    log.debug("getDefaultProject, user=", data);
                    return self.getByRef(data.User.UserProfile._ref);
                }).then(function (data) {
                    log.debug("getDefaultProject, userProfile=", data);
                    return self.getByRef(data.UserProfile.DefaultProject._ref);
                }).then(function (data) {
                    var oid;
                    log.debug("getDefaultProject, defaultProject=", data);
                    oid = data.Project.ObjectID;
                    return self.projects().find("(ObjectID=" + oid + ")").get();
                });
            };
            self.getMyProjects = function () {
                return this.projects().start(1).pageSize(200).order("Name ASC").find("(State = \"Open\")").andParam("workspace", "null").fetchFullObject().getAll().then(function (d) {
                    return d.QueryResult.Results;
                });
            };
            all = ["AllowedAttributeValue", "AllowedQueryOperator", "Artifact", "ArtifactNotification", "Attachment", "AttachmentContent", "AttributeDefinition", "Blocker", "Build", "BuildDefinition", "BuildMetric", "BuildMetricDefinition", "Change", "Changeset", "ConversationPost", "CumulativeFlowData", "Defect", "DefectSuite", "DomainObject", "HierarchicalRequirement", "Iteration", "IterationCumulativeFlowData", "PersistableObject", "PortfolioItem", "PortfolioItem/Feature", "PortfolioItem/Initiative", "PortfolioItem/Strategy", "PortfolioItem/Theme", "Preference", "PreliminaryEstimate", "Program", "Project", "ProjectPermission", "Release", "ReleaseCumulativeFlowData", "Requirement", "Revision", "RevisionHistory", "SCMRepository", "ScopedAttributeDefinition", "State", "Subscription", "Tag", "Task", "TestCase", "TestCaseResult", "TestCaseStep", "TestFolder", "TestSet", "TimeEntryItem", "TimeEntryValue", "TypeDefinition", "User", "UserIterationCapacity", "UserPermission", "UserProfile", "WebLinkDefinition", "Workspace", "WorkspaceConfiguration", "WorkspaceDomainObject", "WorkspacePermission"];
            return all.forEach(function (type) {
                var lowerType;
                lowerType = type.toLowerCase();
                log.debug("Adding method " + type + "s");
                return self[lowerType + "s"] = function () {
                    return new QueryBuilder(self, type + "s");
                };
            });
        };
        return function (baseUrl) {
            return new WSAPI(baseUrl);
        };
    });

}).call(this);
    </script>
    <script>
(function () {
    var __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };

    define('easel-environment-api', ['jquery', 'easel-util'], function ($, util) {
        var EnvironmentApi;
        return EnvironmentApi = (function () {
            function EnvironmentApi(environmentConfig) {
                this.el = __bind(this.el, this);
                this.getPreference = __bind(this.getPreference, this);
                this._injectPrefsIntoEnvironment = __bind(this._injectPrefsIntoEnvironment, this);
                this.registerPreferences = __bind(this.registerPreferences, this);
                this.environment = __bind(this.environment, this);
                this.wsapiUrl = __bind(this.wsapiUrl, this);
                this.lbapiUrl = __bind(this.lbapiUrl, this);
                this.reload = __bind(this.reload, this);
                this.loadEnvironment = __bind(this.loadEnvironment, this);
                this.defaultEnvironment = __bind(this.defaultEnvironment, this);
                this._elementId = environmentConfig.elementId ? environmentConfig.elementId : null;
                this._lbapiUrl = environmentConfig.lbapiUrl ? environmentConfig.lbapiUrl : null;
                this._wsapiUrl = environmentConfig.wsapiUrl ? environmentConfig.wsapiUrl : null;
                this._prefs = {};
                this.loadEnvironment();
            }

            EnvironmentApi.prototype.defaultEnvironment = function () {
                return {};
            };

            EnvironmentApi.prototype.loadEnvironment = function () {
                return this._environment = this.defaultEnvironment();
            };

            EnvironmentApi.prototype.reload = function () {
                return this.loadEnvironment();
            };

            EnvironmentApi.prototype.lbapiUrl = function () {
                return "" + this._lbapiUrl + "/v2.0/service/rally/workspace/" + (this.getWorkspaceOid()) + "/artifact/snapshot/query.js";
            };

            EnvironmentApi.prototype.wsapiUrl = function () {
                return "" + this._wsapiUrl + "/slm/webservice/v2.x/";
            };

            EnvironmentApi.prototype.safeOid = function (o) {
                if (o && o.ObjectID) {
                    return o.ObjectID;
                }
                return null;
            };

            EnvironmentApi.prototype.environment = function () {
                return this._environment;
            };

            EnvironmentApi.prototype.registerPreferences = function (prefs) {
                var item, _i, _len;
                for (_i = 0, _len = prefs.length; _i < _len; _i++) {
                    item = prefs[_i];
                    this._prefs[item.name] = this._getPreferenceValue(item);
                }
                this._injectPrefsIntoEnvironment();
            };

            EnvironmentApi.prototype._getPreferenceValue = function (pref) {
                var value;
                value = pref.value ? pref.value : pref["default"];
                if (pref.type === 'int') {
                    value = parseInt(value);
                }
                return value;
            };

            EnvironmentApi.prototype._injectPrefsIntoEnvironment = function () {
                var key, value, _ref, _results;
                _ref = this._prefs;
                _results = [];
                for (key in _ref) {
                    value = _ref[key];
                    _results.push(this._environment[key] = value);
                }
                return _results;
            };

            EnvironmentApi.prototype.getPreference = function (key) {
                return this._prefs[key];
            };

            EnvironmentApi.prototype.el = function () {
                return $('#' + this._elementId).get(0);
            };

            return EnvironmentApi;

        })();
    });

}).call(this);
    </script>
    <script>
(function () {
requirejs.config({
    paths: {
        'moment': '//cdnjs.cloudflare.com/ajax/libs/moment.js/2.6.0/moment.min',
        'numeral': '//cdnjs.cloudflare.com/ajax/libs/numeral.js/1.5.3/numeral.min',
        'highcharts-more': '//cdnjs.cloudflare.com/ajax/libs/highcharts/3.0.10/highcharts-more'
    },
    shim: {
        'highcharts-more': {
            'deps': ['highcharts']
        }
    }
});

    define('xxx', [
        'lodash',
        'moment',
        'numeral',
        'easel-toolkit',
        'lumenize',
        'highcharts-more'
    ], function (_, moment, numeral, toolkit, lumenize, highcharts_more) {
        var colors = toolkit.Colors;
        var thirtyDaysAgo = moment().subtract('weeks', 12);

        return {
            init: function () {
                var stateField = 'ScheduleState';
                var stateFieldValues = ['Idea', 'Defined', 'In-Progress', 'Completed', 'Accepted'];
                var showBacklogState = false;

                if (!showBacklogState) {
                    stateFieldValues.shift();
                }

                this.config.stateField = stateField;
                this.config.stateFieldValues = stateFieldValues;
            },

            config: {
                // TODO: make easel-engine prefer transform function and ignore transform config
                // TODO: put these into a transform config block

                stateField: null,
                stateFieldValues: null,
                showReady: true, // TODO: config option to separate out artifacts ready to pull into next state

                startOn: thirtyDaysAgo.toISOString(),
                endBefore: moment().toISOString(),
                granularity: lumenize.Time.HOUR,
                tz: 'America/New_York'
            },

            /**
             * Lookback API query. Must return query results (snapshots).
             */
            query: function () {
                var find = {};
                find[this.api().getProjectScopingDown() ? '_ProjectHierarchy' : 'Project'] = this.api().getProjectOid();
                find['_TypeHierarchy'] = { $in: ['Defect', 'HierarchicalRequirement'] };
                find['_ValidFrom'] = { '$gte': thirtyDaysAgo.toISOString() };
                find['_ValidTo'] = { '$gt': thirtyDaysAgo.toISOString() };
                find['Children'] = null;

                return this.lbapi().snapshots()
                    .find(find)
                    .fields(['ObjectID', 'FormattedID', 'Name', '_ValidFrom', '_ValidTo', 'Ready', this.config.stateField])
                    .hydrate([this.config.stateField])
                    .compress(true)
                    .removeUnauthorizedSnapshots(true)
                    .sort({ "_ValidFrom": 1 })
                    .getAll();
            },

            transform: function (success, failure, data) {
                data.Results = this._transformPreprocess(data.Results);
                var transformedData = this._calculateTimeInState(data.Results);
                return transformedData;
            },

            _transformPreprocess: function (data) {
                // TODO: dedupe artifact-state (i.e. correct for things moving back and forth)

                var timeline = this._getTimeline();

                _.each(data, function (row) {
                    this._addTicksToSnapshot(row, timeline);
                    this._fixNullStateValue(row);
                }, this);

                data = this._dedupeArtifacts(data);
                return data;
            },

            _getTimeline: function () {
                var config = {
                    startOn: new lumenize.Time(this.config.startOn, this.config.granularity, this.config.tz),
                    endBefore: new lumenize.Time(this.config.endBefore, this.config.granularity, this.config.tz),
                    // workDayStartOn: { hour: 8 },
                    // workDayEndBefore: { hour: 18 },
                    workDays: this.config.workDays
                };
                var timeline = new lumenize.Timeline(config);
                return timeline;
            },

            _addTicksToSnapshot: function (snapshot, timeline) {
                var ticks = timeline.ticksThatIntersect(snapshot._ValidFrom, snapshot._ValidTo, this.config.tz);
                // also convert from hours to days
                snapshot.ticks = ticks.length / 24;
            },

            _fixNullStateValue: function (snapshot) {
                if (snapshot[this.config.stateField] === null) {
                    snapshot[this.config.stateField] = "null";
                }
                if (snapshot.Ready) {
                    snapshot.Ready = "true";
                } else {
                    snapshot.Ready = "false";
                }
            },

            /**
             * Merge snapshots that have the same ObjectID, state, and Ready values.  This handles
             * items that move backwards in the process.  e.g. pulling a card back into In Dev
             */
            _dedupeArtifacts: function (data) {
                var map = _.reduce(data, function (result, value, key) {
                    // composite key for required dimensions
                    var ckey = value.ObjectID + value[this.config.stateField] + value.Ready;
                    if (ckey in result) {
                        var old = result[ckey];
                        if ((value[this.config.stateField] === old[this.config.stateField]) && (value.Ready === old.Ready)) {
                            result[ckey].ticks += value.ticks;
                        }
                    } else {
                        result[ckey] = value;
                    }
                    return result;
                }, {}, this);
                data = _.map(map, function (row) {
                    return row;
                });
                return data;
            },

            _calculateTimeInState: function (results) {
                var config = this._getCubeConfig();
                var cube = new lumenize.OLAPCube(config);
                cube.addFacts(results);
                var data = _.cloneDeep(cube.getCells());
                return data;
            },

            _getCubeConfig: function () {
                var self = this;
                return {
                    // keepTotals: true,
                    dimensions: [
                        { 'field': self.config.stateField },
                        { 'field': 'Ready' }
                    ],
                    metrics: [
                        { field: 'ticks', f: 'sum', as: 'timeInState_total' },
                        { field: 'ticks', f: 'min', as: 'timeInState_min' },
                        { field: 'ticks', f: 'p25', as: 'timeInState_p25' },
                        { field: 'ticks', f: 'p50', as: 'timeInState_p50' },
                        { field: 'ticks', f: 'p75', as: 'timeInState_p75' },
                        { field: 'ticks', f: 'p95', as: 'timeInState_max' }
                    ]
                };
            },

            visualize: function (success, failure, data) {
                var chartConfig = this._getBasicChartConfig();
                var seriesData = this._getHighchartsSeriesData(data)
                chartConfig.series = [{
                    type: 'boxplot',
                    name: 'Time',
                    data: seriesData
                }];

                chartConfig.xAxis.categories = _.reduce(this.config.stateFieldValues, function (result, value, key) {
                    result.push(value);
                    result.push(value + ' (ready)');
                    return result;
                }, [], this);

                $('#' + this.api().el().id).highcharts(chartConfig);
                return true;
            },

            _getBasicChartConfig: function () {
                return {
                    chart: {
                        type: 'boxplot'
                    },
                    plotOptions: {
                        boxplot: {
                            lineWidth: 2,
                            series: {
                                borderRadius: 4
                            }
                            // fillColor: colors.lightBlue
                        },
                        series: {
                            borderRadius: 4
                        }
                    },
                    legend: {
                        enabled: false
                    },
                    credits: { enabled: false },
                    colors: [
                        colors.blue,
                        colors.darkGreen
                    ],
                    title: { text: "Time spent in state (12 Weeks)" },
                    xAxis: {},
                    yAxis: {
                        title: {
                            text: 'Days in state'
                        },
                        min: 0
                    },
                    tooltip: {
                        formatter: this._tooltipFormatter
                    }
                };
            },

            _getHighchartsSeriesData: function (data) {
                // TODO: make this easier to follow
                // this loops over the state field values at the top of the file, pulls values from the
                // transform data, and appends to the series array

                var seriesData = _.reduce(data, function (result, value, key) {
                    if (!_.contains(this.config.stateFieldValues, value[this.config.stateField])) {
                        return result;
                    }

                    var sortVal = this.config.stateFieldValues.indexOf(value[this.config.stateField]) * 2;
                    if (value.Ready === 'true') {
                        sortVal += 1;
                    }
                    result.push({
                        state: value[this.config.stateField],
                        ready: value.Ready === 'true' ? true : false,
                        sort: sortVal,
                        low: value.timeInState_min,
                        q1: value.timeInState_p25,
                        median: value.timeInState_p50,
                        q3: value.timeInState_p75,
                        high: value.timeInState_max
                    });
                    return result;
                }, [], this);

                seriesData = _.sortBy(seriesData, 'sort');

                return seriesData;
            },

            _tooltipFormatter: function () {
                return '<b><u>' + this.point.category + '</u></b><br/>' +
                    '<b>Max:</b> ' + numeral(this.point.high).format('0.00') + '<br/>' +
                    '<b>p75:</b> ' + numeral(this.point.q3).format('0.00') + '<br/>' +
                    '<b>Median:</b> ' + numeral(this.point.median).format('0.00') + '<br/>' +
                    '<b>p25:</b> ' + numeral(this.point.q1).format('0.00') + '<br/>' +
                    '<b>Min:</b> ' + numeral(this.point.low).format('0.00') + '<br/>';
            }

        }
    });
})();</script>
    <script>
require(['jquery'], function ($) {
    (function () {
        var __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; },
          __hasProp = {}.hasOwnProperty,
          __extends = function (child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

        require(['jquery', 'easel-environment-api', 'easel-log', 'easel-engine', 'xxx'], function ($, EnvironmentApi, log, engine, thechart) {
            var AlmCustomHtmlShimApi, shimApi, shimApiConfig;
            AlmCustomHtmlShimApi = (function (_super) {
                __extends(AlmCustomHtmlShimApi, _super);

                function AlmCustomHtmlShimApi() {
                    this.getProjectsInScope = __bind(this.getProjectsInScope, this);
                    this.getProjectScopingDown = __bind(this.getProjectScopingDown, this);
                    this.getProject = __bind(this.getProject, this);
                    this.getWorkspace = __bind(this.getWorkspace, this);
                    this.getProjectOid = __bind(this.getProjectOid, this);
                    this.getWorkspaceOid = __bind(this.getWorkspaceOid, this);
                    this.defaultEnvironment = __bind(this.defaultEnvironment, this);
                    return AlmCustomHtmlShimApi.__super__.constructor.apply(this, arguments);
                }

                AlmCustomHtmlShimApi.prototype.defaultEnvironment = function () {
                    return {
                        workspaceOid: this.getWorkspaceOid(),
                        projectOid: this.getProjectOid(),
                        projectScopeDown: this.getProjectScopingDown(),
                        projectsInScopeOids: this.getProjectsInScope()
                    };
                };

                AlmCustomHtmlShimApi.prototype.getWorkspaceOid = function () {
                    return __WORKSPACE_OID__;
                };

                AlmCustomHtmlShimApi.prototype.getProjectOid = function () {
                    return __PROJECT_OID__;
                };

                AlmCustomHtmlShimApi.prototype.getWorkspace = function () {
                    return {
                        ObjectID: this.getWorkspaceOid()
                    };
                };

                AlmCustomHtmlShimApi.prototype.getProject = function () {
                    throw new Error('getProject is not supported in an ALM Custom HTML app');
                };

                AlmCustomHtmlShimApi.prototype.getProjectScopingDown = function () {
                    return __PROJECT_SCOPING_DOWN__;
                };

                AlmCustomHtmlShimApi.prototype.getProjectsInScope = function () {
                    return [__PROJECT_OIDS_IN_SCOPE__];
                };

                return AlmCustomHtmlShimApi;

            })(EnvironmentApi);
            window.engine = new engine.Engine(thechart);
            shimApiConfig = {
                elementId: 'thechart',
                lbapiUrl: '/analytics',
                wsapiUrl: ''
            };
            shimApi = new AlmCustomHtmlShimApi(shimApiConfig);
            window.engine.init(shimApi);
            window.engine.launch();
        });

    }).call(this);

});</script>
</head>
<body>
    <div id='thechart'></div>
</body>
</html>
